{"":{"title":"","translated_title":"","question_id":"","language":null,"tags":null,"difficulty":"","save_dir":["questions/serial"],"title_slug":"","question":"## [](https://leetcode-cn.com/problems//)\n\n"},"01-matrix":{"title":"01 Matrix","translated_title":"01 矩阵","question_id":"542","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","广度优先搜索"],"difficulty":"medium","save_dir":["questions/serial/medium/542","questions/tags/深度优先搜索/medium/01-matrix","questions/tags/广度优先搜索/medium/01-matrix"],"title_slug":"01-matrix","question":"## [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n \n\n**示例 1：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n`\n\n**示例 2：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n`\n\n \n\n**提示：**\n\n*   给定矩阵的元素个数不超过 10000。\n*   给定矩阵中至少有一个元素是 0。\n*   矩阵中的元素只在四个方向上相邻: 上、下、左、右。"},"3sum":{"title":"3Sum","translated_title":"三数之和","question_id":"15","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"medium","save_dir":["questions/serial/medium/15","questions/tags/数组/medium/3sum","questions/tags/双指针/medium/3sum"],"title_slug":"3sum","question":"## [三数之和](https://leetcode-cn.com/problems/3sum/)\n\n给你一个包含 _n_ 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 _a，b，c ，_使得 _a + b + c =_ 0 ？请你找出所有满足条件且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n \n\n**示例：**\n\n`给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n`"},"4sum":{"title":"4Sum","translated_title":"四数之和","question_id":"18","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表","双指针"],"difficulty":"medium","save_dir":["questions/serial/medium/18","questions/tags/数组/medium/4sum","questions/tags/哈希表/medium/4sum","questions/tags/双指针/medium/4sum"],"title_slug":"4sum","question":"## [四数之和](https://leetcode-cn.com/problems/4sum/)\n\n给定一个包含 _n_ 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 _a，__b，c_ 和 _d_ ，使得 _a_ + _b_ + _c_ + _d_ 的值与 `target` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n`给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n`"},"4sum-ii":{"title":"4Sum II","translated_title":"四数相加 II","question_id":"454","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/454","questions/tags/哈希表/medium/4sum-ii","questions/tags/二分查找/medium/4sum-ii"],"title_slug":"4sum-ii","question":"## [四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 `(i, j, k, l)` ，使得 `A[i] + B[j] + C[k] + D[l] = 0`。\n\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2\n28\n 到 2\n28\n - 1 之间，最终结果不会超过 2\n31\n - 1 。\n\n**例如:**\n\n`\n**输入:**\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n**输出:**\n2\n\n**解释:**\n两个元组如下:\n1. (0, 0, 0, 1) -\u003e A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -\u003e A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n`"},"array-partition-i":{"title":"Array Partition I","translated_title":"数组拆分 I","question_id":"561","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/561","questions/tags/数组/easy/array-partition-i"],"title_slug":"array-partition-i","question":"## [数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)\n\n给定长度为 `2n`****的整数数组 `nums` ，你的任务是将这些数分成 `n` **** 对, 例如 `(a\n1\n, b\n1\n), (a\n2\n, b\n2\n), ..., (a\nn\n, b\nn\n)` ，使得从 `1` 到 `n` 的 `min(a\ni\n, b\ni\n)` 总和最大。\n\n返回该 **最大总和** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [1,4,3,2]\n**输出：**4\n**解释：**所有可能的分法（忽略元素顺序）为：\n1. (1, 4), (2, 3) -\u003e min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -\u003e min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -\u003e min(1, 2) + min(3, 4) = 1 + 3 = 4\n所以最大总和为 4`\n\n**示例 2：**\n\n`\n**输入：**nums = [6,2,6,5,1,2]\n**输出：**9\n**解释：**最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `nums.length == 2 * n`\n*   `-10\n4\n \n4\n`"},"balanced-binary-tree":{"title":"Balanced Binary Tree","translated_title":"平衡二叉树","question_id":"110","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"easy","save_dir":["questions/serial/easy/110","questions/tags/树/easy/balanced-binary-tree","questions/tags/深度优先搜索/easy/balanced-binary-tree"],"title_slug":"balanced-binary-tree","question":"## [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n\u003e 一个二叉树_每个节点_的左右两个子树的高度差的绝对值不超过 1 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n`\n**输入：**root = [3,9,20,null,null,15,7]\n**输出：**true\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n`\n**输入：**root = [1,2,2,3,3,null,null,4,4]\n**输出：**false\n`\n\n**示例 3：**\n\n`\n**输入：**root = []\n**输出：**true\n`\n\n \n\n**提示：**\n\n*   树中的节点数在范围 `[0, 5000]` 内\n*   `-10\n4\n \n4\n`"},"basic-calculator-ii":{"title":"Basic Calculator II","translated_title":"基本计算器 II","question_id":"227","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","字符串"],"difficulty":"medium","save_dir":["questions/serial/medium/227","questions/tags/栈/medium/basic-calculator-ii","questions/tags/字符串/medium/basic-calculator-ii"],"title_slug":"basic-calculator-ii","question":"## [基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)\n\n实现一个基本的计算器来计算一个简单的字符串表达式的值。\n\n字符串表达式仅包含非负整数，`+`， `-` ，`*`，`/` 四种运算符和空格 ` `。 整数除法仅保留整数部分。\n\n**示例 1:**\n\n`**输入:** \"3+2*2\"\n**输出:** 7\n`\n\n**示例 2:**\n\n`**输入:** \" 3/2 \"\n**输出:** 1`\n\n**示例 3:**\n\n`**输入:** \" 3+5 / 2 \"\n**输出:** 5\n`\n\n**说明：**\n\n*   你可以假设所给定的表达式都是有效的。\n*   请**不要**使用内置的库函数 `eval`。"},"best-time-to-buy-and-sell-stock":{"title":"Best Time to Buy and Sell Stock","translated_title":"买卖股票的最佳时机","question_id":"121","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","动态规划"],"difficulty":"easy","save_dir":["questions/serial/easy/121","questions/tags/数组/easy/best-time-to-buy-and-sell-stock","questions/tags/动态规划/easy/best-time-to-buy-and-sell-stock"],"title_slug":"best-time-to-buy-and-sell-stock","question":"## [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n给定一个数组，它的第 _i_ 个元素是一支给定股票第 _i_ 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n\n注意：你不能在买入股票前卖出股票。\n\n \n\n**示例 1:**\n\n`**输入:** [7,1,5,3,6,4]\n**输出:** 5\n**解释:** 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n`\n\n**示例 2:**\n\n`**输入:** [7,6,4,3,1]\n**输出:** 0\n**解释:** 在这种情况下, 没有交易完成, 所以最大利润为 0。\n`"},"binary-search":{"title":"Binary Search","translated_title":"二分查找","question_id":"792","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/792","questions/tags/二分查找/easy/binary-search"],"title_slug":"binary-search","question":"## [二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 9\n**输出:** 4\n**解释:** 9 出现在 `nums` 中并且下标为 4\n`\n\n**示例 2:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 2\n**输出:** -1\n**解释:** 2 不存在 `nums` 中因此返回 -1\n`\n\n \n\n**提示：**\n\n1.  你可以假设 `nums` 中的所有元素是不重复的。\n2.  `n` 将在 `[1, 10000]`之间。\n3.  `nums` 的每个元素都将在 `[-9999, 9999]`之间。"},"binary-search-tree-iterator":{"title":"Binary Search Tree Iterator","translated_title":"二叉搜索树迭代器","question_id":"173","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","树","设计"],"difficulty":"medium","save_dir":["questions/serial/medium/173","questions/tags/栈/medium/binary-search-tree-iterator","questions/tags/树/medium/binary-search-tree-iterator","questions/tags/设计/medium/binary-search-tree-iterator"],"title_slug":"binary-search-tree-iterator","question":"## [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n \n\n**示例：**\n\n**![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/25/bst-tree.png)**\n\n`BSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false`\n\n \n\n**提示：**\n\n*   `next()` 和 `hasNext()` 操作的时间复杂度是 O(1)，并使用 O(_h_) 内存，其中 _h _是树的高度。\n*   你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 中至少存在一个下一个最小的数。"},"climbing-stairs":{"title":"Climbing Stairs","translated_title":"爬楼梯","question_id":"70","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["动态规划"],"difficulty":"easy","save_dir":["questions/serial/easy/70","questions/tags/动态规划/easy/climbing-stairs"],"title_slug":"climbing-stairs","question":"## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 _n_ 是一个正整数。\n\n**示例 1：**\n\n`**输入：** 2\n**输出：** 2\n**解释：** 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶`\n\n**示例 2：**\n\n`**输入：** 3\n**输出：** 3\n**解释：** 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n`"},"clone-graph":{"title":"Clone Graph","translated_title":"克隆图","question_id":"133","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["深度优先搜索","广度优先搜索","图"],"difficulty":"medium","save_dir":["questions/serial/medium/133","questions/tags/深度优先搜索/medium/clone-graph","questions/tags/广度优先搜索/medium/clone-graph","questions/tags/图/medium/clone-graph"],"title_slug":"clone-graph","question":"## [克隆图](https://leetcode-cn.com/problems/clone-graph/)\n\n给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin) **图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。\n\n图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。\n\n`class Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n}`\n\n \n\n**测试用例格式：**\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。\n\n**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝 **作为对克隆图的引用返回。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)\n\n`**输入：**adjList = [[2,4],[1,3],[2,4],[1,3]]\n**输出：**[[2,4],[1,3],[2,4],[1,3]]\n**解释：** 图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)\n\n`**输入：**adjList = [[]]\n**输出：**[[]]\n**解释：**输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n`\n\n**示例 3：**\n\n`**输入：**adjList = []\n**输出：**[]\n**解释：**这个图是空的，它不含任何节点。\n`\n\n**示例 4：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)\n\n`**输入：**adjList = [[2],[1]]\n**输出：**[[2],[1]]`\n\n \n\n**提示：**\n\n1.  节点数不超过 100 。\n2.  每个节点值 `Node.val` 都是唯一的，`1 \u003c= Node.val \u003c= 100`。\n3.  无向图是一个[简单图](https://baike.baidu.com/item/简单图/1680528?fr=aladdin)，这意味着图中没有重复的边，也没有自环。\n4.  由于图是无向的，如果节点 _p_ 是节点 _q_ 的邻居，那么节点 _q_ 也必须是节点 _p_ 的邻居。\n5.  图是连通图，你可以从给定节点访问到所有节点。"},"concatenation-of-consecutive-binary-numbers":{"title":"Concatenation of Consecutive Binary Numbers","translated_title":"连接连续二进制数字","question_id":"1800","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学"],"difficulty":"medium","save_dir":["questions/serial/medium/1800","questions/tags/数学/medium/concatenation-of-consecutive-binary-numbers"],"title_slug":"concatenation-of-consecutive-binary-numbers","question":"## [连接连续二进制数字](https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/)\n\n给你一个整数 `n` ，请你将 `1` 到 `n` 的二进制表示连接起来，并返回连接结果对应的 **十进制** 数字对 `10\n9\n + 7` 取余的结果。\n\n \n\n**示例 1：**\n\n`**输入：**n = 1\n**输出：**1\n**解释：**二进制的 \"1\" 对应着十进制的 1 。\n`\n\n**示例 2：**\n\n`**输入：**n = 3\n**输出：**27\n**解释：**二进制下，1，2 和 3 分别对应 \"1\" ，\"10\" 和 \"11\" 。\n将它们依次连接，我们得到 \"11011\" ，对应着十进制的 27 。\n`\n\n**示例 3：**\n\n`**输入：**n = 12\n**输出：**505379714\n**解释：**连接结果为 \"1101110010111011110001001101010111100\" 。\n对应的十进制数字为 118505380540 。\n对 10\n9\n + 7 取余后，结果为 505379714 。\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= n \u003c= 10\n5\n`"},"contains-duplicate":{"title":"Contains Duplicate","translated_title":"存在重复元素","question_id":"217","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/217","questions/tags/数组/easy/contains-duplicate","questions/tags/哈希表/easy/contains-duplicate"],"title_slug":"contains-duplicate","question":"## [存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。\n\n \n\n**示例 1:**\n\n`**输入:** [1,2,3,1]\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** [1,2,3,4]\n**输出:** false`\n\n**示例 3:**\n\n`**输入:** [1,1,1,3,3,4,3,2,4,2]\n**输出:** true`"},"contains-duplicate-ii":{"title":"Contains Duplicate II","translated_title":"存在重复元素 II","question_id":"219","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/219","questions/tags/数组/easy/contains-duplicate-ii","questions/tags/哈希表/easy/contains-duplicate-ii"],"title_slug":"contains-duplicate-ii","question":"## [存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n给定一个整数数组和一个整数 _k_，判断数组中是否存在两个不同的索引_ i_ 和_ j_，使得 **nums [i] = nums [j]**，并且 _i_ 和 _j_ 的差的 **绝对值** 至多为 _k_。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,2,3,1], k __ = 3\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** nums = [1,0,1,1], k __ = __ 1\n**输出:** true`\n\n**示例 3:**\n\n`**输入:** nums = [1,2,3,1,2,3], k __ = __ 2\n**输出:** false`"},"contains-duplicate-iii":{"title":"Contains Duplicate III","translated_title":"存在重复元素 III","question_id":"220","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序",""],"difficulty":"medium","save_dir":["questions/serial/medium/220","questions/tags/排序/medium/contains-duplicate-iii","questions/tags/medium/contains-duplicate-iii"],"title_slug":"contains-duplicate-iii","question":"## [存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n在整数数组 `nums` 中，是否存在两个下标 **_i_** 和 **_j_**，使得 **nums [i]** 和 **nums [j]** 的差的绝对值小于等于 _**t**_ ，且满足 **_i_** 和 **_j_** 的差的绝对值也小于等于 _**ķ**_ 。\n\n如果存在则返回 `true`，不存在返回 `false`。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,2,3,1], k __ = 3, t = 0\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** nums = [1,0,1,1], k __ = __ 1, t = 2\n**输出:** true`\n\n**示例 3:**\n\n`**输入:** nums = [1,5,9,1,5,9], k = 2, t = 3\n**输出:** false`"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","translated_title":"完全二叉树的节点个数","question_id":"222","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/222","questions/tags/树/medium/count-complete-tree-nodes","questions/tags/二分查找/medium/count-complete-tree-nodes"],"title_slug":"count-complete-tree-nodes","question":"## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2\nh\n 个节点。\n\n**示例:**\n\n`**输入:** \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n**输出:** 6`"},"count-of-matches-in-tournament":{"title":"Count of Matches in Tournament","translated_title":"比赛中的配对次数","question_id":"1806","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["回溯算法"],"difficulty":"easy","save_dir":["questions/serial/easy/1806","questions/tags/回溯算法/easy/count-of-matches-in-tournament"],"title_slug":"count-of-matches-in-tournament","question":"## [比赛中的配对次数](https://leetcode-cn.com/problems/count-of-matches-in-tournament/)\n\n给你一个整数 `n` ，表示比赛中的队伍数。比赛遵循一种独特的赛制：\n\n*   如果当前队伍数是 **偶数** ，那么每支队伍都会与另一支队伍配对。总共进行 `n / 2` 场比赛，且产生 `n / 2` 支队伍进入下一轮。\n*   如果当前队伍数为 **奇数** ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 `(n - 1) / 2` 场比赛，且产生 `(n - 1) / 2 + 1` 支队伍进入下一轮。\n\n返回在比赛中进行的配对次数，直到决出获胜队伍为止。\n\n \n\n**示例 1：**\n\n`**输入：**n = 7\n**输出：**6\n**解释：**比赛详情：\n- 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。\n- 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 3 + 2 + 1 = 6\n`\n\n**示例 2：**\n\n`**输入：**n = 14\n**输出：**13\n**解释：**比赛详情：\n- 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。\n- 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 \n- 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。\n- 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 7 + 3 + 2 + 1 = 13\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= n \u003c= 200`"},"count-primes":{"title":"Count Primes","translated_title":"计数质数","question_id":"204","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","数学"],"difficulty":"easy","save_dir":["questions/serial/easy/204","questions/tags/哈希表/easy/count-primes","questions/tags/数学/easy/count-primes"],"title_slug":"count-primes","question":"## [计数质数](https://leetcode-cn.com/problems/count-primes/)\n\n统计所有小于非负整数 _`n` _的质数的数量。\n\n \n\n**示例 1：**\n\n`**输入：**n = 10\n**输出：**4\n**解释：**小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n`\n\n**示例 2：**\n\n`**输入：**n = 0\n**输出：**0\n`\n\n**示例 3：**\n\n`**输入：**n = 1\n**输出**：0\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 5 * 10\n6\n`"},"count-the-number-of-consistent-strings":{"title":"Count the Number of Consistent Strings","translated_title":"统计一致字符串的数目","question_id":"1786","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/1786","questions/tags/字符串/easy/count-the-number-of-consistent-strings"],"title_slug":"count-the-number-of-consistent-strings","question":"## [统计一致字符串的数目](https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/)\n\n给你一个由不同字符组成的字符串 `allowed` 和一个字符串数组 `words` 。如果一个字符串的每一个字符都在 `allowed` 中，就称这个字符串是 **一致**字符串。\n\n请你返回 `words` 数组中 **一致** 字符串的数目。\n\n \n\n**示例 1：**\n\n`\n**输入：**allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"]\n**输出：**2\n**解释：**字符串 \"aaab\" 和 \"baa\" 都是一致字符串，因为它们只包含字符 'a' 和 'b' 。\n`\n\n**示例 2：**\n\n`\n**输入：**allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"]\n**输出：**7\n**解释：**所有字符串都是一致的。\n`\n\n**示例 3：**\n\n`\n**输入：**allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"]\n**输出：**4\n**解释：**字符串 \"cc\"，\"acd\"，\"ac\" 和 \"d\" 是一致字符串。\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `1 \n \n26`\n*   `1 \u003c= words[i].length \u003c= 10`\n*   `allowed` 中的字符 **互不相同** 。\n*   `words[i]` 和 `allowed` 只包含小写英文字母。"},"create-maximum-number":{"title":"Create Maximum Number","translated_title":"拼接最大数","question_id":"321","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","动态规划"],"difficulty":"hard","save_dir":["questions/serial/hard/321","questions/tags/贪心算法/hard/create-maximum-number","questions/tags/动态规划/hard/create-maximum-number"],"title_slug":"create-maximum-number","question":"## [拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)\n\n给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k \u003c= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。\n\n求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。\n\n**说明:** 请尽可能地优化你算法的时间和空间复杂度。\n\n**示例 1:**\n\n`**输入:**\nnums1 = `[3, 4, 6, 5]`\nnums2 = `[9, 1, 2, 5, 8, 3]`\nk = `5`\n**输出:**\n`[9, 8, 6, 5, 3]``\n\n**示例 2:**\n\n`**输入:**\nnums1 = `[6, 7]`\nnums2 = `[6, 0, 4]`\nk = `5`\n**输出:**\n`[6, 7, 6, 0, 4]``\n\n**示例 3:**\n\n`**输入:**\nnums1 = `[3, 9]`\nnums2 = `[8, 9]`\nk = `3`\n**输出:**\n`[9, 8, 9]``"},"decode-string":{"title":"Decode String","translated_title":"字符串解码","question_id":"394","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","深度优先搜索"],"difficulty":"medium","save_dir":["questions/serial/medium/394","questions/tags/栈/medium/decode-string","questions/tags/深度优先搜索/medium/decode-string"],"title_slug":"decode-string","question":"## [字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 _encoded_string_ 正好重复 _k_ 次。注意 _k_ 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 _k_ ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n`**输入：**s = \"3[a]2[bc]\"\n**输出：**\"aaabcbc\"\n`\n\n**示例 2：**\n\n`**输入：**s = \"3[a2[c]]\"\n**输出：**\"accaccacc\"\n`\n\n**示例 3：**\n\n`**输入：**s = \"2[abc]3[cd]ef\"\n**输出：**\"abcabccdcdcdef\"\n`\n\n**示例 4：**\n\n`**输入：**s = \"abc3[cd]xyz\"\n**输出：**\"abccdcdcdxyz\"\n`"},"delete-node-in-a-bst":{"title":"Delete Node in a BST","translated_title":"删除二叉搜索树中的节点","question_id":"450","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"medium","save_dir":["questions/serial/medium/450","questions/tags/树/medium/delete-node-in-a-bst"],"title_slug":"delete-node-in-a-bst","question":"## [删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n\n给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n1.  首先找到需要删除的节点；\n2.  如果找到了，删除它。\n\n**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n**示例:**\n\n`\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n`"},"delete-node-in-a-linked-list":{"title":"Delete Node in a Linked List","translated_title":"删除链表中的节点","question_id":"237","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["链表"],"difficulty":"easy","save_dir":["questions/serial/easy/237","questions/tags/链表/easy/delete-node-in-a-linked-list"],"title_slug":"delete-node-in-a-linked-list","question":"## [删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)\n\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 **要被删除的节点** 。\n\n \n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png)\n\n \n\n**示例 1：**\n\n`**输入：**head = [4,5,1,9], node = 5\n**输出：**[4,1,9]\n**解释：**给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9.\n`\n\n**示例 2：**\n\n`**输入：**head = [4,5,1,9], node = 1\n**输出：**[4,5,9]\n**解释：**给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9.\n`\n\n \n\n**提示：**\n\n*   链表至少包含两个节点。\n*   链表中所有节点的值都是唯一的。\n*   给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n*   不要从你的函数中返回任何结果。"},"design-add-and-search-words-data-structure":{"title":"Design Add and Search Words Data Structure","translated_title":"添加与搜索单词 - 数据结构设计","question_id":"211","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","字典树","回溯算法"],"difficulty":"medium","save_dir":["questions/serial/medium/211","questions/tags/设计/medium/design-add-and-search-words-data-structure","questions/tags/字典树/medium/design-add-and-search-words-data-structure","questions/tags/回溯算法/medium/design-add-and-search-words-data-structure"],"title_slug":"design-add-and-search-words-data-structure","question":"## [添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)\n\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 `WordDictionary` ：\n\n*   `WordDictionary()` 初始化词典对象\n*   `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配\n*   `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回  `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n**输出：**\n[null,null,null,null,false,true,true,true]\n\n**解释：**\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= word.length \u003c= 500`\n*   `addWord` 中的 `word` 由小写英文字母组成\n*   `search` 中的 `word` 由 '.' 或小写英文字母组成\n*   最调用多 `50000` 次 `addWord` 和 `search`"},"design-hashset":{"title":"Design HashSet","translated_title":"设计哈希集合","question_id":"816","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/816","questions/tags/设计/easy/design-hashset","questions/tags/哈希表/easy/design-hashset"],"title_slug":"design-hashset","question":"## [设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)\n\n不使用任何内建的哈希表库设计一个哈希集合\n\n具体地说，你的设计应该包含以下的功能\n\n*   `add(value)`：向哈希集合中插入一个值。\n*   `contains(value)` ：返回哈希集合中是否存在这个值。\n*   `remove(value)`：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\n\n**示例:**\n\n`MyHashSet hashSet = new MyHashSet();\nhashSet.add(1);         \nhashSet.add(2);         \nhashSet.contains(1);    // 返回 true\nhashSet.contains(3);    // 返回 false (未找到)\nhashSet.add(2);          \nhashSet.contains(2);    // 返回 true\nhashSet.remove(2);          \nhashSet.contains(2);    // 返回  false (已经被删除)\n`\n\n**注意：**\n\n*   所有的值都在 `[0, 1000000]`的范围内。\n*   操作的总数目在`[1, 10000]`范围内。\n*   不要使用内建的哈希集合库。"},"dota2-senate":{"title":"Dota2 Senate","translated_title":"Dota2 参议院","question_id":"649","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法"],"difficulty":"medium","save_dir":["questions/serial/medium/649","questions/tags/贪心算法/medium/dota2-senate"],"title_slug":"dota2-senate","question":"## [Dota2 参议院](https://leetcode-cn.com/problems/dota2-senate/)\n\nDota2 的世界里有两个阵营：`Radiant`(天辉)和 `Dire`(夜魇)\n\nDota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的`**一**`项：\n\n1.\n\n`禁止一名参议员的权利`：\n\n参议员可以让另一位参议员在这一轮和随后的几轮中丧失**所有的权利**。\n\n2.\n\n`宣布胜利`：\n\n          如果参议员发现有权利投票的参议员都是**同一个阵营的**，他可以宣布胜利并决定在游戏中的有关变化。\n\n \n\n给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。\n\n以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。\n\n假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `Radiant` 或 `Dire`。\n\n \n\n**示例 1：**\n\n`\n**输入：**\"RD\"\n**输出：**\"Radiant\"\n**解释：**`第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人`\n`\n\n**示例 2：**\n\n`\n**输入：**\"RDD\"\n**输出：**\"Dire\"\n**解释：**\n第一轮中,第一个`来自 Radiant 阵营的`参议员可以使用第一项权利禁止第二个参议员的权利\n第二个`来自 Dire 阵营的`参议员会被跳过因为他的权利被禁止\n第三个`来自 Dire 阵营的`参议员可以使用他的第一项权利禁止第一个参议员的权利\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n`\n\n \n\n**提示：**\n\n*   给定字符串的长度在 `[1, 10,000]` 之间.\n\n "},"excel-sheet-column-number":{"title":"Excel Sheet Column Number","translated_title":"Excel表列序号","question_id":"171","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学"],"difficulty":"easy","save_dir":["questions/serial/easy/171","questions/tags/数学/easy/excel-sheet-column-number"],"title_slug":"excel-sheet-column-number","question":"## [Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)\n\n给定一个Excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n`    A -\u003e 1\n    B -\u003e 2\n    C -\u003e 3\n    ...\n    Z -\u003e 26\n    AA -\u003e 27\n    AB -\u003e 28 \n    ...\n`\n\n**示例 1:**\n\n`**输入:** \"A\"\n**输出:** 1\n`\n\n**示例 2:**\n\n`**输入:** \"AB\"\n**输出:** 28\n`\n\n**示例 3:**\n\n`**输入:** \"ZY\"\n**输出:** 701`\n\n**致谢：**  \n\n特别感谢 [@ts](http://leetcode.com/discuss/user/ts) 添加此问题并创建所有测试用例。"},"fibonacci-number":{"title":"Fibonacci Number","translated_title":"斐波那契数","question_id":"1013","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/1013","questions/tags/数组/easy/fibonacci-number"],"title_slug":"fibonacci-number","question":"## [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)\n\n**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n`F(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1.\n`\n\n给定 `N`，计算 `F(N)`。\n\n \n\n**示例 1：**\n\n`**输入：**2\n**输出：**1\n**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1.\n`\n\n**示例 2：**\n\n`**输入：**3\n**输出：**2\n**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2.\n`\n\n**示例 3：**\n\n`**输入：**4\n**输出：**3\n**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3.\n`\n\n \n\n**提示：**\n\n*   0 ≤ `N` ≤ 30"},"find-first-and-last-position-of-element-in-sorted-array":{"title":"Find First and Last Position of Element in Sorted Array","translated_title":"在排序数组中查找元素的第一个和最后一个位置","question_id":"34","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/34","questions/tags/数组/medium/find-first-and-last-position-of-element-in-sorted-array","questions/tags/二分查找/medium/find-first-and-last-position-of-element-in-sorted-array"],"title_slug":"find-first-and-last-position-of-element-in-sorted-array","question":"## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n\n**进阶：**\n\n*   你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 8\n**输出：**[3,4]`\n\n**示例 2：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 6\n**输出：**[-1,-1]`\n\n**示例 3：**\n\n`\n**输入：**nums = [], target = 0\n**输出：**[-1,-1]`\n\n \n\n**提示：**\n\n*   `0 \u003c= nums.length \u003c= 105`\n*   `-109 \u003c= nums[i] \u003c= 109`\n*   `nums` 是一个非递减数组\n*   `-109 \u003c= target \u003c= 109`"},"find-k-closest-elements":{"title":"Find K Closest Elements","translated_title":"找到 K 个最接近的元素","question_id":"658","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/658","questions/tags/二分查找/medium/find-k-closest-elements"],"title_slug":"find-k-closest-elements","question":"## [找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)\n\n给定一个排序好的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。\n\n整数 `a` 比整数 `b` 更接近 `x` 需要满足：\n\n*   `|a - x| \n4\n`\n*   数组里的每个元素与 `x` 的绝对值不超过 `10\n4\n`"},"find-median-from-data-stream":{"title":"Find Median from Data Stream","translated_title":"数据流的中位数","question_id":"295","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","设计"],"difficulty":"hard","save_dir":["questions/serial/hard/295","questions/tags/堆/hard/find-median-from-data-stream","questions/tags/设计/hard/find-median-from-data-stream"],"title_slug":"find-median-from-data-stream","question":"## [数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)\n\n中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。\n\n例如，\n\n[2,3,4] 的中位数是 3\n\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n\n设计一个支持以下两种操作的数据结构：\n\n*   void addNum(int num) - 从数据流中添加一个整数到数据结构中。\n*   double findMedian() - 返回目前所有元素的中位数。\n\n**示例：**\n\n`addNum(1)\naddNum(2)\nfindMedian() -\u003e 1.5\naddNum(3) \nfindMedian() -\u003e 2`\n\n**进阶:**\n\n1.  如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？\n2.  如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？"},"find-minimum-in-rotated-sorted-array":{"title":"Find Minimum in Rotated Sorted Array","translated_title":"寻找旋转排序数组中的最小值","question_id":"153","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/153","questions/tags/数组/medium/find-minimum-in-rotated-sorted-array","questions/tags/二分查找/medium/find-minimum-in-rotated-sorted-array"],"title_slug":"find-minimum-in-rotated-sorted-array","question":"## [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 `[0,1,2,4,5,6,7]`  **** 可能变为 `[4,5,6,7,0,1,2]` 。\n\n请找出其中最小的元素。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [3,4,5,1,2]\n**输出：**1\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [4,5,6,7,0,1,2]\n**输出：**0\n`\n\n**示例 3：**\n\n`\n**输入：**nums = [1]\n**输出：**1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-5000 \u003c= nums[i] \u003c= 5000`\n*   `nums` 中的所有整数都是 **唯一** 的\n*   `nums` 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转"},"find-peak-element":{"title":"Find Peak Element","translated_title":"寻找峰值","question_id":"162","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/162","questions/tags/数组/medium/find-peak-element","questions/tags/二分查找/medium/find-peak-element"],"title_slug":"find-peak-element","question":"## [寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。\n\n数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。\n\n你可以假设 `nums[-1] = nums[n] = -∞`。\n\n**示例 1:**\n\n`**输入:** **nums** = `[1,2,3,1]`\n**输出:** 2\n**解释:** 3 是峰值元素，你的函数应该返回其索引 2。`\n\n**示例 2:**\n\n`**输入:** **nums** = `[`1,2,1,3,5,6,4]\n**输出:** 1 或 5 \n**解释:** 你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n`\n\n**说明:**\n\n你的解法应该是 _O_(_logN_)_ _时间复杂度的。"},"find-pivot-index":{"title":"Find Pivot Index","translated_title":"寻找数组的中心索引","question_id":"724","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/724","questions/tags/数组/easy/find-pivot-index"],"title_slug":"find-pivot-index","question":"## [寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)\n\n给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。\n\n我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n \n\n**示例 1：**\n\n`**输入：**\nnums = [1, 7, 3, 6, 5, 6]\n**输出：**3\n**解释：**\n索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。\n同时, 3 也是第一个符合要求的中心索引。\n`\n\n**示例 2：**\n\n`**输入：**\nnums = [1, 2, 3]\n**输出：**-1\n**解释：**\n数组中不存在满足此条件的中心索引。`\n\n \n\n**说明：**\n\n*   `nums` 的长度范围为 `[0, 10000]`。\n*   任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。"},"find-smallest-letter-greater-than-target":{"title":"Find Smallest Letter Greater Than Target","translated_title":"寻找比目标字母大的最小字母","question_id":"745","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/745","questions/tags/二分查找/easy/find-smallest-letter-greater-than-target"],"title_slug":"find-smallest-letter-greater-than-target","question":"## [寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)\n\n给你一个排序后的字符列表 `letters` ，列表中只包含小写英文字母。另给出一个目标字母 `target`，请你寻找在这一有序列表里比目标字母大的最小字母。\n\n在比较时，字母是依序循环出现的。举个例子：\n\n*   如果目标字母 `target = 'z'` 并且字符列表为 `letters = ['a', 'b']`，则答案返回 `'a'`\n\n \n\n**示例：**\n\n`**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\n**输出:** \"c\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\n**输出:** \"f\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\n**输出:** \"f\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"g\"\n**输出:** \"j\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"j\"\n**输出:** \"c\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"k\"\n**输出:** \"c\"\n`\n\n \n\n**提示：**\n\n1.  `letters`长度范围在`[2, 10000]`区间内。\n2.  `letters` 仅由小写字母组成，最少包含两个不同的字母。\n3.  目标字母`target` 是一个小写字母。"},"find-the-duplicate-number":{"title":"Find the Duplicate Number","translated_title":"寻找重复数","question_id":"287","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/287","questions/tags/数组/medium/find-the-duplicate-number","questions/tags/双指针/medium/find-the-duplicate-number","questions/tags/二分查找/medium/find-the-duplicate-number"],"title_slug":"find-the-duplicate-number","question":"## [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)\n\n给定一个包含 _n_ + 1 个整数的数组 _nums_，其数字都在 1 到 _n _之间（包括 1 和 _n_），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n\n**示例 1:**\n\n`**输入:** `[1,3,4,2,2]`\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** [3,1,3,4,2]\n**输出:** 3\n`\n\n**说明：**\n\n1.  **不能**更改原数组（假设数组是只读的）。\n2.  只能使用额外的 _O_(1) 的空间。\n3.  时间复杂度小于 _O_(_n_\n2\n) 。\n4.  数组中只有一个重复的数字，但它可能不止重复出现一次。"},"first-bad-version":{"title":"First Bad Version","translated_title":"第一个错误的版本","question_id":"278","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/278","questions/tags/二分查找/easy/first-bad-version"],"title_slug":"first-bad-version","question":"## [第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n**示例:**\n\n`给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n`调用 isBadVersion(3) -\u003e false\n调用 isBadVersion(5) -\u003e true\n调用 isBadVersion(4) -\u003e true\n\n所以，4 是第一个错误的版本。 ``"},"first-missing-positive":{"title":"First Missing Positive","translated_title":"缺失的第一个正数","question_id":"41","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"hard","save_dir":["questions/serial/hard/41","questions/tags/数组/hard/first-missing-positive"],"title_slug":"first-missing-positive","question":"## [缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)\n\n给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。\n\n \n\n**示例 1:**\n\n`输入: [1,2,0]\n输出: 3\n`\n\n**示例 2:**\n\n`输入: [3,4,-1,1]\n输出: 2\n`\n\n**示例 3:**\n\n`输入: [7,8,9,11,12]\n输出: 1\n`\n\n \n\n**提示：**\n\n你的算法的时间复杂度应为O(_n_)，并且只能使用常数级别的额外空间。"},"first-unique-character-in-a-string":{"title":"First Unique Character in a String","translated_title":"字符串中的第一个唯一字符","question_id":"387","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/387","questions/tags/哈希表/easy/first-unique-character-in-a-string","questions/tags/字符串/easy/first-unique-character-in-a-string"],"title_slug":"first-unique-character-in-a-string","question":"## [字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n \n\n**示例：**\n\n`s = \"leetcode\"\n返回 0\n\ns = \"loveleetcode\"\n返回 2\n`\n\n \n\n**提示：**你可以假定该字符串只包含小写字母。"},"fizz-buzz":{"title":"Fizz Buzz","translated_title":"Fizz Buzz","question_id":"412","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":null,"difficulty":"easy","save_dir":["questions/serial/easy/412"],"title_slug":"fizz-buzz","question":"## [Fizz Buzz](https://leetcode-cn.com/problems/fizz-buzz/)\n\n写一个程序，输出从 1 到 _n_ 数字的字符串表示。\n\n1. 如果 _n _是3的倍数，输出“Fizz”；\n\n2. 如果 _n _是5的倍数，输出“Buzz”；\n\n3.如果 _n _同时是3和5的倍数，输出 “FizzBuzz”。\n\n**示例：**\n\n`n = 15,\n\n返回:\n[\n    \"1\",\n    \"2\",\n    \"Fizz\",\n    \"4\",\n    \"Buzz\",\n    \"Fizz\",\n    \"7\",\n    \"8\",\n    \"Fizz\",\n    \"Buzz\",\n    \"11\",\n    \"Fizz\",\n    \"13\",\n    \"14\",\n    \"FizzBuzz\"\n]\n`"},"flood-fill":{"title":"Flood Fill","translated_title":"图像渲染","question_id":"733","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索"],"difficulty":"easy","save_dir":["questions/serial/easy/733","questions/tags/深度优先搜索/easy/flood-fill"],"title_slug":"flood-fill","question":"## [图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n`\n**输入:** \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n**输出:** [[2,2,2],[2,2,0],[2,0,1]]\n**解析:** \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n`\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 \u003c= sr \u003c image.length` 和 `0 \u003c= sc \u003c image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。"},"goal-parser-interpretation":{"title":"Goal Parser Interpretation","translated_title":"设计 Goal 解析器","question_id":"1797","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/1797","questions/tags/字符串/easy/goal-parser-interpretation"],"title_slug":"goal-parser-interpretation","question":"## [设计 Goal 解析器](https://leetcode-cn.com/problems/goal-parser-interpretation/)\n\n请你设计一个可以解释字符串 `command` 的 **Goal 解析器** 。`command` 由 `\"G\"`、`\"()\"` 和/或 `\"(al)\"` 按某种顺序组成。Goal 解析器会将 `\"G\"` 解释为字符串 `\"G\"`、`\"()\"` 解释为字符串 `\"o\"` ，`\"(al)\"` 解释为字符串 `\"al\"` 。然后，按原顺序将经解释得到的字符串连接成一个字符串。\n\n给你字符串 `command` ，返回 __ **Goal_\n** _解析器 \n对 __ `command` 的解释结果。\n\n \n\n**示例 1：**\n\n`**输入：**command = \"G()(al)\"\n**输出：**\"Goal\"\n**解释：**Goal 解析器解释命令的步骤如下所示：\nG -\u003e G\n() -\u003e o\n(al) -\u003e al\n最后连接得到的结果是 \"Goal\"\n`\n\n**示例 2：**\n\n`**输入：**command = \"G()()()()(al)\"\n**输出：**\"Gooooal\"\n`\n\n**示例 3：**\n\n`**输入：**command = \"(al)G(al)()()G\"\n**输出：**\"alGalooG\"\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= command.length \u003c= 100`\n*   `command` 由 `\"G\"`、`\"()\"` 和/或 `\"(al)\"` 按某种顺序组成"},"group-anagrams":{"title":"Group Anagrams","translated_title":"字母异位词分组","question_id":"49","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","字符串"],"difficulty":"medium","save_dir":["questions/serial/medium/49","questions/tags/哈希表/medium/group-anagrams","questions/tags/字符串/medium/group-anagrams"],"title_slug":"group-anagrams","question":"## [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n**示例:**\n\n`**输入:** `[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]`\n**输出:**\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]`\n\n**说明：**\n\n*   所有输入均为小写字母。\n*   不考虑答案输出的顺序。"},"guess-number-higher-or-lower":{"title":"Guess Number Higher or Lower","translated_title":"猜数字大小","question_id":"374","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php"],"tags":["二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/374","questions/tags/二分查找/easy/guess-number-higher-or-lower"],"title_slug":"guess-number-higher-or-lower","question":"## [猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)\n\n猜数字游戏的规则如下：\n\n*   每轮游戏，我都会从 **1** 到 _**n**_ 随机选择一个数字。 请你猜选出的是哪个数字。\n*   如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有 3 种可能的情况（`-1`，`1` 或 `0`）：\n\n*   -1：我选出的数字比你猜的数字小 `pick \n num`\n*   0：我选出的数字和你猜的数字一样。恭喜！你猜对了！`pick == num`\n\n \n\n**示例 1：**\n\n`\n**输入：**n = 10, pick = 6\n**输出：**6\n`\n\n**示例 2：**\n\n`\n**输入：**n = 1, pick = 1\n**输出：**1\n`\n\n**示例 3：**\n\n`\n**输入：**n = 2, pick = 1\n**输出：**1\n`\n\n**示例 4：**\n\n`\n**输入：**n = 2, pick = 2\n**输出：**2\n`\n\n \n\n**提示：**\n\n*   `1 \n31\n - 1`\n*   `1 \u003c= pick \u003c= n`"},"hamming-distance":{"title":"Hamming Distance","translated_title":"汉明距离","question_id":"461","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算"],"difficulty":"easy","save_dir":["questions/serial/easy/461","questions/tags/位运算/easy/hamming-distance"],"title_slug":"hamming-distance","question":"## [汉明距离](https://leetcode-cn.com/problems/hamming-distance/)\n\n两个整数之间的[汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)指的是这两个数字对应二进制位不同的位置的数目。\n\n给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。\n\n**注意：**  \n\n0 ≤ `x`, `y` \u003c 2\n31\n.\n\n**示例:**\n\n`\n**输入:** x = 1, y = 4\n\n**输出:** 2\n\n**解释:**\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\n上面的箭头指出了对应二进制位不同的位置。\n`"},"happy-number":{"title":"Happy Number","translated_title":"快乐数","question_id":"202","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","数学"],"difficulty":"easy","save_dir":["questions/serial/easy/202","questions/tags/哈希表/easy/happy-number","questions/tags/数学/easy/happy-number"],"title_slug":"happy-number","question":"## [快乐数](https://leetcode-cn.com/problems/happy-number/)\n\n编写一个算法来判断一个数 `n` 是不是快乐数。\n\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。如果 **可以变为**  1，那么这个数就是快乐数。\n\n如果 `n` 是快乐数就返回 `True` ；不是，则返回 `False` 。\n\n \n\n**示例：**\n\n`**输入：**19\n**输出：**true\n**解释：** 1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n`"},"implement-queue-using-stacks":{"title":"Implement Queue using Stacks","translated_title":"用栈实现队列","question_id":"232","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"easy","save_dir":["questions/serial/easy/232","questions/tags/栈/easy/implement-queue-using-stacks","questions/tags/设计/easy/implement-queue-using-stacks"],"title_slug":"implement-queue-using-stacks","question":"## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n*   `void push(int x)` 将元素 x 推到队列的末尾\n*   `int pop()` 从队列的开头移除并返回元素\n*   `int peek()` 返回队列开头的元素\n*   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n \n\n**说明：**\n\n*   你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n*   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**进阶：**\n\n*   你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n**输出：**\n[null, null, null, 1, 1, false]\n\n**解释：**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= x \u003c= 9`\n*   最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n*   假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）"},"implement-stack-using-queues":{"title":"Implement Stack using Queues","translated_title":"用队列实现栈","question_id":"225","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"easy","save_dir":["questions/serial/easy/225","questions/tags/栈/easy/implement-stack-using-queues","questions/tags/设计/easy/implement-stack-using-queues"],"title_slug":"implement-stack-using-queues","question":"## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n使用队列实现栈的下列操作：\n\n*   push(x) -- 元素 x 入栈\n*   pop() -- 移除栈顶元素\n*   top() -- 获取栈顶元素\n*   empty() -- 返回栈是否为空\n\n**注意:**\n\n*   你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。\n*   你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n*   你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。"},"implement-strstr":{"title":"Implement strStr()","translated_title":"实现 strStr()","question_id":"28","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/28","questions/tags/双指针/easy/implement-strstr","questions/tags/字符串/easy/implement-strstr"],"title_slug":"implement-strstr","question":"## [实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n\n实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  **-1**。\n\n**示例 1:**\n\n`**输入:** haystack = \"hello\", needle = \"ll\"\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** haystack = \"aaaaa\", needle = \"bba\"\n**输出:** -1\n`\n\n**说明:**\n\n当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。"},"implement-trie-prefix-tree":{"title":"Implement Trie (Prefix Tree)","translated_title":"实现 Trie (前缀树)","question_id":"208","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","字典树"],"difficulty":"medium","save_dir":["questions/serial/medium/208","questions/tags/设计/medium/implement-trie-prefix-tree","questions/tags/字典树/medium/implement-trie-prefix-tree"],"title_slug":"implement-trie-prefix-tree","question":"## [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n\n实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。\n\n**示例:**\n\n`Trie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true`\n\n**说明:**\n\n*   你可以假设所有的输入都是由小写字母 `a-z` 构成的。\n*   保证所有输入均为非空字符串。"},"increasing-triplet-subsequence":{"title":"Increasing Triplet Subsequence","translated_title":"递增的三元子序列","question_id":"334","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":null,"difficulty":"medium","save_dir":["questions/serial/medium/334"],"title_slug":"increasing-triplet-subsequence","question":"## [递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)\n\n给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。\n\n数学表达式如下:\n\n\u003e 如果存在这样的 _i, j, k, _ 且满足 0 ≤ _i_ \u003c _j_ \u003c _k_ ≤ _n_-1，  \n\u003e \n\u003e 使得 _arr[i]_ \u003c _arr[j]_ \u003c _arr[k]_ ，返回 true ; 否则返回 false 。\n\n**说明:** 要求算法的时间复杂度为 O(_n_)，空间复杂度为 O(_1_) 。\n\n**示例 1:**\n\n`**输入:** [1,2,3,4,5]\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** [5,4,3,2,1]\n**输出:** false`"},"insert-delete-getrandom-o1":{"title":"Insert Delete GetRandom O(1)","translated_title":"常数时间插入、删除和获取随机元素","question_id":"380","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","数组","哈希表"],"difficulty":"medium","save_dir":["questions/serial/medium/380","questions/tags/设计/medium/insert-delete-getrandom-o1","questions/tags/数组/medium/insert-delete-getrandom-o1","questions/tags/哈希表/medium/insert-delete-getrandom-o1"],"title_slug":"insert-delete-getrandom-o1","question":"## [常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)\n\n设计一个支持在_平均 _时间复杂度 **O(1)** 下，执行以下操作的数据结构。\n\n1.  `insert(val)`：当元素 val 不存在时，向集合中插入该项。\n2.  `remove(val)`：元素 val 存在时，从集合中移除该项。\n3.  `getRandom`：随机返回现有集合中的一项。每个元素应该有**相同的概率**被返回。\n\n**示例 :**\n\n`\n// 初始化一个空的集合。\nRandomizedSet randomSet = new RandomizedSet();\n\n// 向集合中插入 1 。返回 true 表示 1 被成功地插入。\nrandomSet.insert(1);\n\n// 返回 false ，表示集合中不存在 2 。\nrandomSet.remove(2);\n\n// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。\nrandomSet.insert(2);\n\n// getRandom 应随机返回 1 或 2 。\nrandomSet.getRandom();\n\n// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。\nrandomSet.remove(1);\n\n// 2 已在集合中，所以返回 false 。\nrandomSet.insert(2);\n\n// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。\nrandomSet.getRandom();\n`"},"insert-into-a-binary-search-tree":{"title":"Insert into a Binary Search Tree","translated_title":"二叉搜索树中的插入操作","question_id":"784","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"medium","save_dir":["questions/serial/medium/784","questions/tags/树/medium/insert-into-a-binary-search-tree"],"title_slug":"insert-into-a-binary-search-tree","question":"## [二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n\n**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n`\n**输入：**root = [4,2,7,1,3], val = 5\n**输出：**[4,2,7,1,3,5]\n**解释：**另一个满足题目要求可以通过的树是：\n![image](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)\n`\n\n**示例 2：**\n\n`\n**输入：**root = [40,20,60,10,30,50,70], val = 25\n**输出：**[40,20,60,10,30,50,70,null,null,25]\n`\n\n**示例 3：**\n\n`\n**输入：**root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n**输出：**[4,2,7,1,3,5]\n`\n\n \n\n \n\n**提示：**\n\n*   给定的树上的节点数介于 `0` 和 `10^4` 之间\n*   每个节点都有一个唯一整数值，取值范围从 `0` 到 `10^8`\n*   `-10^8 \u003c= val \u003c= 10^8`\n*   新值和原始二叉搜索树中的任意节点值都不同"},"intersection-of-two-arrays":{"title":"Intersection of Two Arrays","translated_title":"两个数组的交集","question_id":"349","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表","双指针","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/349","questions/tags/排序/easy/intersection-of-two-arrays","questions/tags/哈希表/easy/intersection-of-two-arrays","questions/tags/双指针/easy/intersection-of-two-arrays","questions/tags/二分查找/easy/intersection-of-two-arrays"],"title_slug":"intersection-of-two-arrays","question":"## [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n \n\n**示例 1：**\n\n`**输入：**nums1 = [1,2,2,1], nums2 = [2,2]\n**输出：**[2]\n`\n\n**示例 2：**\n\n`**输入：**nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**输出：**[9,4]`\n\n \n\n**说明：**\n\n*   输出结果中的每个元素一定是唯一的。\n*   我们可以不考虑输出结果的顺序。"},"intersection-of-two-arrays-ii":{"title":"Intersection of Two Arrays II","translated_title":"两个数组的交集 II","question_id":"350","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表","双指针","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/350","questions/tags/排序/easy/intersection-of-two-arrays-ii","questions/tags/哈希表/easy/intersection-of-two-arrays-ii","questions/tags/双指针/easy/intersection-of-two-arrays-ii","questions/tags/二分查找/easy/intersection-of-two-arrays-ii"],"title_slug":"intersection-of-two-arrays-ii","question":"## [两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n \n\n**示例 1：**\n\n`**输入：**nums1 = [1,2,2,1], nums2 = [2,2]\n**输出：**[2,2]\n`\n\n**示例 2:**\n\n`**输入：**nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**输出：**[4,9]`\n\n \n\n**说明：**\n\n*   输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。\n*   我们可以不考虑输出结果的顺序。\n\n**\n进阶**：\n\n\n*   如果给定的数组已经排好序呢？你将如何优化你的算法？\n*   如果 _nums1 _的大小比 _nums2 _小很多，哪种方法更优？\n*   如果 _nums2 _的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？"},"isomorphic-strings":{"title":"Isomorphic Strings","translated_title":"同构字符串","question_id":"205","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/205","questions/tags/哈希表/easy/isomorphic-strings"],"title_slug":"isomorphic-strings","question":"## [同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)\n\n给定两个字符串 _**s **_和 **_t_**，判断它们是否是同构的。\n\n如果 _**s **_中的字符可以被替换得到 **_t _**，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n**示例 1:**\n\n`**输入:** **_s_** = `\"egg\", `**_t =_ **`\"add\"`\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** **_s_** = `\"foo\", `**_t =_ **`\"bar\"`\n**输出:** false`\n\n**示例 3:**\n\n`**输入:** **_s_** = `\"paper\", `**_t =_ **`\"title\"`\n**输出:** true`\n\n**说明:**  \n\n你可以假设 _**s **_和 **_t_ **具有相同的长度。"},"jewels-and-stones":{"title":"Jewels and Stones","translated_title":"宝石与石头","question_id":"782","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/782","questions/tags/哈希表/easy/jewels-and-stones"],"title_slug":"jewels-and-stones","question":"## [宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)\n\n 给定字符串`J` 代表石头中宝石的类型，和字符串 `S`代表你拥有的石头。 `S` 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n\n`J` 中的字母不重复，`J` 和 `S`中的所有字符都是字母。字母区分大小写，因此`\"a\"`和`\"A\"`是不同类型的石头。\n\n**示例 1:**\n\n`**输入:** J = \"aA\", S = \"aAAbbbb\"\n**输出:** 3\n`\n\n**示例 2:**\n\n`**输入:** J = \"z\", S = \"ZZ\"\n**输出:** 0\n`\n\n**注意:**\n\n*   `S` 和 `J` 最多含有50个字母。\n*    `J` 中的字符不重复。"},"k-th-symbol-in-grammar":{"title":"K-th Symbol in Grammar","translated_title":"第K个语法符号","question_id":"795","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["递归"],"difficulty":"medium","save_dir":["questions/serial/medium/795","questions/tags/递归/medium/k-th-symbol-in-grammar"],"title_slug":"k-th-symbol-in-grammar","question":"## [第K个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\n在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。\n\n给定行数 `N` 和序数 `K`，返回第 `N` 行中第 `K`个字符。（`K`从1开始）\n\n**例子:**\n\n`**输入:** N = 1, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 2\n**输出:** 1\n\n**输入:** N = 4, K = 5\n**输出:** 1\n\n**解释:**\n第一行: 0\n第二行: 01\n第三行: 0110\n第四行: 01101001\n`\n\n**注意：**\n\n1.  `N` 的范围 `[1, 30]`.\n2.  `K` 的范围 `[1, 2^(N-1)]`."},"keys-and-rooms":{"title":"Keys and Rooms","translated_title":"钥匙和房间","question_id":"871","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","图"],"difficulty":"medium","save_dir":["questions/serial/medium/871","questions/tags/深度优先搜索/medium/keys-and-rooms","questions/tags/图/medium/keys-and-rooms"],"title_slug":"keys-and-rooms","question":"## [钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n`**输入:** [[1],[2],[3],[]]\n**输出:** true\n**解释:** \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n`\n\n**示例 2：**\n\n`**输入：**[[1,3],[3,0,1],[2],[0]]\n**输出：**false\n**解释：**我们不能进入 2 号房间。\n`\n\n**提示：**\n\n1.  `1 \u003c= rooms.length \u003c= 1000`\n2.  `0 \u003c= rooms[i].length \u003c= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。"},"kth-largest-element-in-a-stream":{"title":"Kth Largest Element in a Stream","translated_title":"数据流中的第 K 大元素","question_id":"789","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","设计"],"difficulty":"easy","save_dir":["questions/serial/easy/789","questions/tags/堆/easy/kth-largest-element-in-a-stream","questions/tags/设计/easy/kth-largest-element-in-a-stream"],"title_slug":"kth-largest-element-in-a-stream","question":"## [数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)\n\n设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。\n\n请实现 `KthLargest` 类：\n\n*   `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。\n*   `int add(int val)` 返回当前数据流中第 `k` 大的元素。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n**输出：**\n[null, 4, 5, 5, 8, 8]\n\n**解释：**\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `0 \n4\n`\n*   `-10\n4\n \n4\n`\n*   `-10\n4\n \n4\n`\n*   最多调用 `add` 方法 `10\n4\n` 次\n*   题目数据保证，在查找第 `k` 大元素时，数组中至少有 `k` 个元素"},"kth-largest-element-in-an-array":{"title":"Kth Largest Element in an Array","translated_title":"数组中的第K个最大元素","question_id":"215","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","分治算法"],"difficulty":"medium","save_dir":["questions/serial/medium/215","questions/tags/堆/medium/kth-largest-element-in-an-array","questions/tags/分治算法/medium/kth-largest-element-in-an-array"],"title_slug":"kth-largest-element-in-an-array","question":"## [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)\n\n在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n**示例 1:**\n\n`**输入:** `[3,2,1,5,6,4] 和` k = 2\n**输出:** 5\n`\n\n**示例 2:**\n\n`**输入:** `[3,2,3,1,2,4,5,5,6] 和` k = 4\n**输出:** 4`\n\n**说明:** \n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。"},"kth-smallest-element-in-a-bst":{"title":"Kth Smallest Element in a BST","translated_title":"二叉搜索树中第K小的元素","question_id":"230","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/230","questions/tags/树/medium/kth-smallest-element-in-a-bst","questions/tags/二分查找/medium/kth-smallest-element-in-a-bst"],"title_slug":"kth-smallest-element-in-a-bst","question":"## [二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)\n\n给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 **k **个最小的元素。\n\n**说明：**  \n\n你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n\n**示例 1:**\n\n`**输入:** root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n**输出:** 1`\n\n**示例 2:**\n\n`**输入:** root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n**输出:** 3`\n\n**进阶：**  \n\n如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 `kthSmallest` 函数？"},"kth-smallest-element-in-a-sorted-matrix":{"title":"Kth Smallest Element in a Sorted Matrix","translated_title":"有序矩阵中第K小的元素","question_id":"378","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/378","questions/tags/堆/medium/kth-smallest-element-in-a-sorted-matrix","questions/tags/二分查找/medium/kth-smallest-element-in-a-sorted-matrix"],"title_slug":"kth-smallest-element-in-a-sorted-matrix","question":"## [有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n给定一个 _`n x n` _矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。  \n\n请注意，它是排序后的第 `k` 小元素，而不是第 `k` 个不同的元素。\n\n \n\n**示例：**\n\n`matrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\n返回 13。\n`\n\n \n\n**提示：**  \n\n你可以假设 k 的值永远是有效的，`1 ≤ k ≤ n\n2 \n`。"},"largest-number":{"title":"Largest Number","translated_title":"最大数","question_id":"179","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序"],"difficulty":"medium","save_dir":["questions/serial/medium/179","questions/tags/排序/medium/largest-number"],"title_slug":"largest-number","question":"## [最大数](https://leetcode-cn.com/problems/largest-number/)\n\n给定一组非负整数 `nums`，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。\n\n**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。\n\n \n\n**示例 1：**\n\n`\n**输入`：`**`nums = [10,2]`\n**输出：**`\"210\"``\n\n**示例 2：**\n\n`\n**输入`：`**`nums = [3,30,34,5,9]`\n**输出：**`\"9534330\"`\n`\n\n**示例 3：**\n\n`\n**输入`：`**nums = [1]\n**输出：**\"1\"\n`\n\n**示例 4：**\n\n`\n**输入`：`**nums = [10]\n**输出：**\"10\"\n`\n\n \n\n**提示：**\n\n*   `1 \n9\n`"},"lemonade-change":{"title":"Lemonade Change","translated_title":"柠檬水找零","question_id":"890","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法"],"difficulty":"easy","save_dir":["questions/serial/easy/890","questions/tags/贪心算法/easy/lemonade-change"],"title_slug":"lemonade-change","question":"## [柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)\n\n在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。\n\n顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n\n每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n\n注意，一开始你手头没有任何零钱。\n\n如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n\n**示例 1：**\n\n`**输入：**[5,5,5,10,20]\n**输出：**true\n**解释：** 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。\n第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。\n第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。\n由于所有客户都得到了正确的找零，所以我们输出 true。\n`\n\n**示例 2：**\n\n`**输入：**[5,5,10]\n**输出：**true\n`\n\n**示例 3：**\n\n`**输入：**[10,10]\n**输出：**false\n`\n\n**示例 4：**\n\n`**输入：**[5,5,10,10,20]\n**输出：**false\n**解释：**\n前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。\n对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。\n对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。\n由于不是每位顾客都得到了正确的找零，所以答案是 false。\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= bills.length \u003c= 10000`\n*   `bills[i]` 不是 `5` 就是 `10` 或是 `20` "},"longest-common-prefix":{"title":"Longest Common Prefix","translated_title":"最长公共前缀","question_id":"14","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/14","questions/tags/字符串/easy/longest-common-prefix"],"title_slug":"longest-common-prefix","question":"## [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n**示例 1:**\n\n`**输入:** [\"flower\",\"flow\",\"flight\"]\n**输出:** \"fl\"\n`\n\n**示例 2:**\n\n`**输入:** [\"dog\",\"racecar\",\"car\"]\n**输出:** \"\"\n**解释:** 输入不存在公共前缀。\n`\n\n**说明:**\n\n所有输入只包含小写字母 `a-z` 。"},"longest-palindromic-substring":{"title":"Longest Palindromic Substring","translated_title":"最长回文子串","question_id":"5","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串","动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/5","questions/tags/字符串/medium/longest-palindromic-substring","questions/tags/动态规划/medium/longest-palindromic-substring"],"title_slug":"longest-palindromic-substring","question":"## [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。\n\n**示例 1：**\n\n`**输入:** \"babad\"\n**输出:** \"bab\"\n**注意:** \"aba\" 也是一个有效答案。\n`\n\n**示例 2：**\n\n`**输入:** \"cbbd\"\n**输出:** \"bb\"\n`"},"longest-substring-without-repeating-characters":{"title":"Longest Substring Without Repeating Characters","translated_title":"无重复字符的最长子串","question_id":"3","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","双指针","字符串",""],"difficulty":"medium","save_dir":["questions/serial/medium/3","questions/tags/哈希表/medium/longest-substring-without-repeating-characters","questions/tags/双指针/medium/longest-substring-without-repeating-characters","questions/tags/字符串/medium/longest-substring-without-repeating-characters","questions/tags/medium/longest-substring-without-repeating-characters"],"title_slug":"longest-substring-without-repeating-characters","question":"## [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串**的长度。\n\n \n\n**示例 1:**\n\n`\n**输入:** s = \"abcabcbb\"\n**输出:** 3 \n**解释:** 因为无重复字符的最长子串是 `\"abc\"，所以其`长度为 3。\n`\n\n**示例 2:**\n\n`\n**输入:** s = \"bbbbb\"\n**输出:** 1\n**解释:** 因为无重复字符的最长子串是 `\"b\"`，所以其长度为 1。\n`\n\n**示例 3:**\n\n`\n**输入:** s = \"pwwkew\"\n**输出:** 3\n**解释:** 因为无重复字符的最长子串是 `\"wke\"`，所以其长度为 3。\n     请注意，你的答案必须是 **子串** 的长度，`\"pwke\"` 是一个_子序列，_不是子串。\n`\n\n**示例 4:**\n\n`\n**输入:** s = \"\"\n**输出:** 0\n`\n\n \n\n**提示：**\n\n*   `0 \n4\n`\n*   `s` 由英文字母、数字、符号和空格组成"},"lowest-common-ancestor-of-a-binary-search-tree":{"title":"Lowest Common Ancestor of a Binary Search Tree","translated_title":"二叉搜索树的最近公共祖先","question_id":"235","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"easy","save_dir":["questions/serial/easy/235","questions/tags/树/easy/lowest-common-ancestor-of-a-binary-search-tree"],"title_slug":"lowest-common-ancestor-of-a-binary-search-tree","question":"## [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)\n\n \n\n**示例 1:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**输出:** 6 \n**解释:** 节点 `2 `和节点 `8 `的最近公共祖先是 `6。`\n`\n\n**示例 2:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**输出:** 2\n**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。`\n\n \n\n**说明:**\n\n*   所有节点的值都是唯一的。\n*   p、q 为不同节点且均存在于给定的二叉搜索树中。"},"lowest-common-ancestor-of-a-binary-tree":{"title":"Lowest Common Ancestor of a Binary Tree","translated_title":"二叉树的最近公共祖先","question_id":"236","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"medium","save_dir":["questions/serial/medium/236","questions/tags/树/medium/lowest-common-ancestor-of-a-binary-tree"],"title_slug":"lowest-common-ancestor-of-a-binary-tree","question":"## [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)\n\n \n\n**示例 1:**\n\n`**输入:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n**输出:** 3\n**解释:** 节点 `5 `和节点 `1 `的最近公共祖先是节点 `3。`\n`\n\n**示例 2:**\n\n`**输入:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n**输出:** 5\n**解释:** 节点 `5 `和节点 `4 `的最近公共祖先是节点 `5。`因为根据定义最近公共祖先节点可以为节点本身。\n`\n\n \n\n**说明:**\n\n*   所有节点的值都是唯一的。\n*   p、q 为不同节点且均存在于给定的二叉树中。"},"majority-element":{"title":"Majority Element","translated_title":"多数元素","question_id":"169","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算","数组","分治算法"],"difficulty":"easy","save_dir":["questions/serial/easy/169","questions/tags/位运算/easy/majority-element","questions/tags/数组/easy/majority-element","questions/tags/分治算法/easy/majority-element"],"title_slug":"majority-element","question":"## [多数元素](https://leetcode-cn.com/problems/majority-element/)\n\n给定一个大小为 _n_ 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n**示例 1:**\n\n`**输入:** [3,2,3]\n**输出:** 3`\n\n**示例 2:**\n\n`**输入:** [2,2,1,1,1,2,2]\n**输出:** 2\n`"},"map-sum-pairs":{"title":"Map Sum Pairs","translated_title":"键值映射","question_id":"677","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字典树"],"difficulty":"medium","save_dir":["questions/serial/medium/677","questions/tags/字典树/medium/map-sum-pairs"],"title_slug":"map-sum-pairs","question":"## [键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)\n\n实现一个 `MapSum` 类，支持两个方法，`insert` 和 `sum`：\n\n*   `MapSum()` 初始化 `MapSum` 对象\n*   `void insert(String key, int val)` 插入 `key-val` 键值对，字符串表示键 `key` ，整数表示值 `val` 。如果键 `key` 已经存在，那么原来的键值对将被替代成新的键值对。\n*   `int sum(string prefix)` 返回所有以该前缀 `prefix` 开头的键 `key` 的值的总和。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n**输出：**\n[null, null, 3, null, 5]\n\n**解释：**\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // return 3 (\nap\nple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // return 5 (\nap\nple + \nap\np = 3 + 2 = 5)\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= key.length, prefix.length \u003c= 50`\n*   `key` 和 `prefix` 仅由小写英文字母组成\n*   `1 \u003c= val \u003c= 1000`\n*   最多调用 `50` 次 `insert` 和 `sum`"},"max-consecutive-ones":{"title":"Max Consecutive Ones","translated_title":"最大连续1的个数","question_id":"485","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/485","questions/tags/数组/easy/max-consecutive-ones"],"title_slug":"max-consecutive-ones","question":"## [最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)\n\n给定一个二进制数组， 计算其中最大连续1的个数。\n\n**示例 1:**\n\n`\n**输入:** [1,1,0,1,1,1]\n**输出:** 3\n**解释:** 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.\n`\n\n**注意：**\n\n*   输入的数组只包含 `0` 和`1`。\n*   输入数组的长度是正整数，且不超过 10,000。"},"max-number-of-k-sum-pairs":{"title":"Max Number of K-Sum Pairs","translated_title":"K 和数对的最大数目","question_id":"1798","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"medium","save_dir":["questions/serial/medium/1798","questions/tags/哈希表/medium/max-number-of-k-sum-pairs"],"title_slug":"max-number-of-k-sum-pairs","question":"## [K 和数对的最大数目](https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/)\n\n给你一个整数数组 `nums` 和一个整数 `k` 。\n\n每一步操作中，你需要从数组中选出和为 `k` 的两个整数，并将它们移出数组。\n\n返回你可以对数组执行的最大操作数。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [1,2,3,4], k = 5\n**输出：**2\n**解释：**开始时 nums = [1,2,3,4]：\n- 移出 1 和 4 ，之后 nums = [2,3]\n- 移出 2 和 3 ，之后 nums = []\n不再有和为 5 的数对，因此最多执行 2 次操作。`\n\n**示例 2：**\n\n`\n**输入：**nums = [3,1,3,4,3], k = 6\n**输出：**1\n**解释：**开始时 nums = [3,1,3,4,3]：\n- 移出前两个 3 ，之后nums = [1,4,3]\n不再有和为 6 的数对，因此最多执行 1 次操作。`\n\n \n\n**提示：**\n\n*   `1 \n5\n`\n*   `1 \n9\n`\n*   `1 \n9\n`"},"maximum-repeating-substring":{"title":"Maximum Repeating Substring","translated_title":"最大重复子字符串","question_id":"1764","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/1764","questions/tags/字符串/easy/maximum-repeating-substring"],"title_slug":"maximum-repeating-substring","question":"## [最大重复子字符串](https://leetcode-cn.com/problems/maximum-repeating-substring/)\n\n给你一个字符串 `sequence` ，如果字符串 `word` 连续重复 `k` 次形成的字符串是 `sequence` 的一个子字符串，那么单词 `word` 的 **重复值为 `k`** **** 。单词 `word` 的 **最****大重复值** 是单词 `word` 在 `sequence` 中最大的重复值。如果 `word` 不是 `sequence` 的子串，那么重复值 `k` 为 `0` 。\n\n给你一个字符串 `sequence` 和 `word` ，请你返回 **最大重复值 `k`** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ab\"\n**输出：**2\n**解释：**\"abab\" 是 \"**abab**c\" 的子字符串。\n`\n\n**示例 2：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ba\"\n**输出：**1\n**解释：**\"ba\" 是 \"a**ba**bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n`\n\n**示例 3：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ac\"\n**输出：**0\n**解释：**\"ac\" 不是 \"ababc\" 的子字符串。\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= sequence.length \u003c= 100`\n*   `1 \u003c= word.length \u003c= 100`\n*   `sequence` 和 `word` 都只包含小写英文字母。"},"maximum-xor-of-two-numbers-in-an-array":{"title":"Maximum XOR of Two Numbers in an Array","translated_title":"数组中两个数的最大异或值","question_id":"421","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算","字典树"],"difficulty":"medium","save_dir":["questions/serial/medium/421","questions/tags/位运算/medium/maximum-xor-of-two-numbers-in-an-array","questions/tags/字典树/medium/maximum-xor-of-two-numbers-in-an-array"],"title_slug":"maximum-xor-of-two-numbers-in-an-array","question":"## [数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)\n\n给定一个非空数组，数组中元素为 a\n0\n, a\n1\n, a\n2\n, … , a\nn-1\n，其中 0 ≤ a\ni\n \u003c 2\n31 \n。\n\n找到 a\ni\n 和a\nj \n最大的异或 (XOR) 运算结果，其中0 ≤ _i_,  _j_ \u003c _n _。\n\n你能在O(_n_)的时间解决这个问题吗？\n\n**示例:**\n\n`\n**输入:** [3, 10, 5, 25, 2, 8]\n\n**输出:** 28\n\n**解释:** 最大的结果是 **5** ^ **25** = 28.\n`"},"merge-sorted-array":{"title":"Merge Sorted Array","translated_title":"合并两个有序数组","question_id":"88","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"easy","save_dir":["questions/serial/easy/88","questions/tags/数组/easy/merge-sorted-array","questions/tags/双指针/easy/merge-sorted-array"],"title_slug":"merge-sorted-array","question":"## [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)\n\n给你两个有序整数数组 _nums1_ 和 _nums2_，请你将 _nums2_ 合并到 _nums1_中_，_使 _nums1_ 成为一个有序数组。\n\n \n\n**说明：**\n\n*   初始化 _nums1_ 和 _nums2_ 的元素数量分别为 _m_ 和 _n_ 。\n*   你可以假设 _nums1_有足够的空间（空间大小大于或等于 _m + n_）来保存 _nums2_ 中的元素。\n\n \n\n**示例：**\n\n`\n**输入：**\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n**输出：**[1,2,2,3,5,6]`\n\n \n\n**提示：**\n\n*   `-10^9 \u003c= nums1[i], nums2[i] \u003c= 10^9`\n*   `nums1.length == m + n`\n*   `nums2.length == n`"},"merge-two-sorted-lists":{"title":"Merge Two Sorted Lists","translated_title":"合并两个有序链表","question_id":"21","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"easy","save_dir":["questions/serial/easy/21","questions/tags/链表/easy/merge-two-sorted-lists"],"title_slug":"merge-two-sorted-lists","question":"## [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n**示例：**\n\n`**输入：**1-\u003e2-\u003e4, 1-\u003e3-\u003e4\n**输出：**1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4\n`"},"minimum-index-sum-of-two-lists":{"title":"Minimum Index Sum of Two Lists","translated_title":"两个列表的最小索引总和","question_id":"599","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/599","questions/tags/哈希表/easy/minimum-index-sum-of-two-lists"],"title_slug":"minimum-index-sum-of-two-lists","question":"## [两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)\n\n假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。\n\n你需要帮助他们用**最少的索引和**找出他们**共同喜爱的餐厅**。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。\n\n**示例 1:**\n\n`**输入:**\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n**输出:** [\"Shogun\"]\n**解释:** 他们唯一共同喜爱的餐厅是“Shogun”。\n`\n\n**示例 2:**\n\n`**输入:**\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"KFC\", \"Shogun\", \"Burger King\"]\n**输出:** [\"Shogun\"]\n**解释:** 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n`\n\n**提示:**\n\n1.  两个列表的长度范围都在 [1, 1000]内。\n2.  两个列表中的字符串的长度将在[1，30]的范围内。\n3.  下标从0开始，到列表的长度减1。\n4.  两个列表都没有重复的元素。"},"missing-number":{"title":"Missing Number","translated_title":"丢失的数字","question_id":"268","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算","数组","数学"],"difficulty":"easy","save_dir":["questions/serial/easy/268","questions/tags/位运算/easy/missing-number","questions/tags/数组/easy/missing-number","questions/tags/数学/easy/missing-number"],"title_slug":"missing-number","question":"## [丢失的数字](https://leetcode-cn.com/problems/missing-number/)\n\n给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。\n\n \n\n**进阶：**\n\n*   你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [3,0,1]\n**输出：**2\n**解释：**n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。`\n\n**示例 2：**\n\n`\n**输入：**nums = [0,1]\n**输出：**2\n**解释：**n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。`\n\n**示例 3：**\n\n`\n**输入：**nums = [9,6,4,2,3,5,7,0,1]\n**输出：**8\n**解释：**n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。`\n\n**示例 4：**\n\n`\n**输入：**nums = [0]\n**输出：**1\n**解释：**n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。`\n\n \n\n**提示：**\n\n*   `n == nums.length`\n*   `1 \n4\n`\n*   `0 \u003c= nums[i] \u003c= n`\n*   `nums` 中的所有数字都 **独一无二**"},"move-zeroes":{"title":"Move Zeroes","translated_title":"移动零","question_id":"283","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"easy","save_dir":["questions/serial/easy/283","questions/tags/数组/easy/move-zeroes","questions/tags/双指针/easy/move-zeroes"],"title_slug":"move-zeroes","question":"## [移动零](https://leetcode-cn.com/problems/move-zeroes/)\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**示例:**\n\n`**输入:** `[0,1,0,3,12]`\n**输出:** `[1,3,12,0,0]``\n\n**说明**:\n\n1.  必须在原数组上操作，不能拷贝额外的数组。\n2.  尽量减少操作次数。"},"n-ary-tree-postorder-traversal":{"title":"N-ary Tree Postorder Traversal","translated_title":"N叉树的后序遍历","question_id":"776","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php"],"tags":["树"],"difficulty":"easy","save_dir":["questions/serial/easy/776","questions/tags/树/easy/n-ary-tree-postorder-traversal"],"title_slug":"n-ary-tree-postorder-traversal","question":"## [N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的_后序遍历_。\n\n例如，给定一个 `3叉树` :\n\n \n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png)\n\n \n\n返回其后序遍历: `[5,6,3,2,4,1]`.\n\n \n\n**说明:** 递归法很简单，你可以使用迭代法完成此题吗?"},"n-ary-tree-preorder-traversal":{"title":"N-ary Tree Preorder Traversal","translated_title":"N叉树的前序遍历","question_id":"775","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php"],"tags":["树"],"difficulty":"easy","save_dir":["questions/serial/easy/775","questions/tags/树/easy/n-ary-tree-preorder-traversal"],"title_slug":"n-ary-tree-preorder-traversal","question":"## [N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的_前序遍历_。\n\n例如，给定一个 `3叉树` :\n\n \n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png)\n\n \n\n返回其前序遍历: `[1,3,5,6,2,4]`。\n\n \n\n**说明: **递归法很简单，你可以使用迭代法完成此题吗?"},"number-of-1-bits":{"title":"Number of 1 Bits","translated_title":"位1的个数","question_id":"191","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算"],"difficulty":"easy","save_dir":["questions/serial/easy/191","questions/tags/位运算/easy/number-of-1-bits"],"title_slug":"number-of-1-bits","question":"## [位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)\n\n编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。\n\n \n\n**提示：**\n\n*   请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n*   在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的 **示例 3** 中，输入表示有符号整数 `-3`。\n\n \n\n**进阶**：\n\n*   如果多次调用这个函数，你将如何优化你的算法？\n\n \n\n**示例 1：**\n\n`\n**输入：**00000000000000000000000000001011\n**输出：**3\n**解释：**输入的二进制串 `**00000000000000000000000000001011** 中，共有三位为 '1'。`\n`\n\n**示例 2：**\n\n`\n**输入：**00000000000000000000000010000000\n**输出：**1\n**解释：**输入的二进制串 **00000000000000000000000010000000** 中，共有一位为 '1'。\n`\n\n**示例 3：**\n\n`\n**输入：**11111111111111111111111111111101\n**输出：**31\n**解释：**输入的二进制串 **11111111111111111111111111111101** 中，共有 31 位为 '1'。`\n\n \n\n**提示：**\n\n*   输入必须是长度为 `32` 的 **二进制串** 。\n\n "},"partitioning-into-minimum-number-of-deci-binary-numbers":{"title":"Partitioning Into Minimum Number Of Deci-Binary Numbers","translated_title":"十-二进制数的最少数目","question_id":"1807","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法"],"difficulty":"medium","save_dir":["questions/serial/medium/1807","questions/tags/贪心算法/medium/partitioning-into-minimum-number-of-deci-binary-numbers"],"title_slug":"partitioning-into-minimum-number-of-deci-binary-numbers","question":"## [十-二进制数的最少数目](https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/)\n\n如果一个十进制数字不含任何前导零，且每一位上的数字不是 `0` 就是 `1` ，那么该数字就是一个 **十-二进制数** 。例如，`101` 和 `1100` 都是 **十-二进制数**，而 `112` 和 `3001` 不是。\n\n给你一个表示十进制整数的字符串 `n` ，返回和为 `n` 的 **十-二进制数** 的最少数目。\n\n \n\n**示例 1：**\n\n`**输入：**n = \"32\"\n**输出：**3\n**解释：**10 + 11 + 11 = 32\n`\n\n**示例 2：**\n\n`**输入：**n = \"82734\"\n**输出：**8\n`\n\n**示例 3：**\n\n`**输入：**n = \"27346209830709182346\"\n**输出：**9\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= n.length \u003c= 10\n5\n`\n*   `n` 仅由数字组成\n*   `n` 不含任何前导零并总是表示正整数"},"pascals-triangle":{"title":"Pascal's Triangle","translated_title":"杨辉三角","question_id":"118","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/118","questions/tags/数组/easy/pascals-triangle"],"title_slug":"pascals-triangle","question":"## [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\n给定一个非负整数 _numRows，_生成杨辉三角的前 _numRows _行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 5\n**输出:**\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]`"},"pascals-triangle-ii":{"title":"Pascal's Triangle II","translated_title":"杨辉三角 II","question_id":"119","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/119","questions/tags/数组/easy/pascals-triangle-ii"],"title_slug":"pascals-triangle-ii","question":"## [杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n给定一个非负索引 _k_，其中 _k_ ≤ 33，返回杨辉三角的第 _k_ 行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 3\n**输出:** [1,3,3,1]\n`\n\n**进阶：**\n\n你可以优化你的算法到 _O_(_k_) 空间复杂度吗？"},"plus-one":{"title":"Plus One","translated_title":"加一","question_id":"66","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/66","questions/tags/数组/easy/plus-one"],"title_slug":"plus-one","question":"## [加一](https://leetcode-cn.com/problems/plus-one/)\n\n给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n \n\n**示例 1：**\n\n`\n**输入：**digits = [1,2,3]\n**输出：**[1,2,4]\n**解释：**输入数组表示数字 123。\n`\n\n**示例 2：**\n\n`\n**输入：**digits = [4,3,2,1]\n**输出：**[4,3,2,2]\n**解释：**输入数组表示数字 4321。\n`\n\n**示例 3：**\n\n`\n**输入：**digits = [0]\n**输出：**[1]\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= digits.length \u003c= 100`\n*   `0 \u003c= digits[i] \u003c= 9`"},"power-of-three":{"title":"Power of Three","translated_title":"3的幂","question_id":"326","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学"],"difficulty":"easy","save_dir":["questions/serial/easy/326","questions/tags/数学/easy/power-of-three"],"title_slug":"power-of-three","question":"## [3的幂](https://leetcode-cn.com/problems/power-of-three/)\n\n给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。\n\n整数 `n` 是 3 的幂次方需满足：存在整数 `x` 使得 `n == 3\nx\n`\n\n \n\n**示例 1：**\n\n`\n**输入：**n = 27\n**输出：**true\n`\n\n**示例 2：**\n\n`\n**输入：**n = 0\n**输出：**false\n`\n\n**示例 3：**\n\n`\n**输入：**n = 9\n**输出：**true\n`\n\n**示例 4：**\n\n`\n**输入：**n = 45\n**输出：**false\n`\n\n \n\n**提示：**\n\n*   `-2\n31\n \n31\n - 1`\n\n \n\n**进阶：**\n\n*   你能不使用循环或者递归来完成本题吗？"},"powx-n":{"title":"Pow(x, n)","translated_title":"Pow(x, n)","question_id":"50","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/50","questions/tags/数学/medium/powx-n","questions/tags/二分查找/medium/powx-n"],"title_slug":"powx-n","question":"## [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。\n\n**示例 1:**\n\n`**输入:** 2.00000, 10\n**输出:** 1024.00000\n`\n\n**示例 2:**\n\n`**输入:** 2.10000, 3\n**输出:** 9.26100\n`\n\n**示例 3:**\n\n`**输入:** 2.00000, -2\n**输出:** 0.25000\n**解释:** 2\n-2\n = 1/2\n2\n = 1/4 = 0.25`\n\n**说明:**\n\n*   -100.0 \u003c _x_ \u003c 100.0\n*   _n_ 是 32 位有符号整数，其数值范围是 [−2\n31\n, 2\n31 \n− 1] 。"},"remove-duplicates-from-sorted-array":{"title":"Remove Duplicates from Sorted Array","translated_title":"删除排序数组中的重复项","question_id":"26","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"easy","save_dir":["questions/serial/easy/26","questions/tags/数组/easy/remove-duplicates-from-sorted-array","questions/tags/双指针/easy/remove-duplicates-from-sorted-array"],"title_slug":"remove-duplicates-from-sorted-array","question":"## [删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)\n\n给定一个排序数组，你需要在 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **[原地] (https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n \n\n**示例 1:**\n\n`给定数组 _nums_ = **[1,1,2]**, \n\n函数应该返回新的长度 **2**, 并且原数组 _nums_ 的前两个元素被修改为 **`1`**, **`2`**。 \n\n你不需要考虑数组中超出新长度后面的元素。`\n\n**示例 2:**\n\n`给定 _nums_ = **[0,0,1,1,1,2,2,3,3,4]**,\n\n函数应该返回新的长度 **5**, 并且原数组 _nums_ 的前五个元素被修改为 **`0`**, **`1`**, **`2`**, **`3`**, **`4`**。\n\n你不需要考虑数组中超出新长度后面的元素。\n`\n\n \n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n`// **nums** 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中**该长度范围内**的所有元素。\nfor (int i = 0; i \u003c len; i++) {\n    print(nums[i]);\n}\n`"},"remove-element":{"title":"Remove Element","translated_title":"移除元素","question_id":"27","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"easy","save_dir":["questions/serial/easy/27","questions/tags/数组/easy/remove-element","questions/tags/双指针/easy/remove-element"],"title_slug":"remove-element","question":"## [移除元素](https://leetcode-cn.com/problems/remove-element/)\n\n给你一个数组 _nums _和一个值 _val_，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 _val _的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **[原地] (https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)修改输入数组**。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n \n\n**示例 1:**\n\n`给定 _nums_ = **[3,2,2,3]**, _val_ = **3**,\n\n函数应该返回新的长度 **2**, 并且 _nums_ 中的前两个元素均为 **2**。\n\n你不需要考虑数组中超出新长度后面的元素。\n`\n\n**示例 2:**\n\n`给定 _nums_ = **[0,1,2,2,3,0,4,2]**, _val_ = **2**,\n\n函数应该返回新的长度 **`5`**, 并且 _nums_ 中的前五个元素为 **`0`**, **`1`**, **`3`**, **`0`**, **4**。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n`\n\n \n\n**说明:**\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n`// **nums** 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 **该长度范围内** 的所有元素。\nfor (int i = 0; i \u003c len; i++) {\n    print(nums[i]);\n}\n`"},"replace-words":{"title":"Replace Words","translated_title":"单词替换","question_id":"648","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字典树","哈希表"],"difficulty":"medium","save_dir":["questions/serial/medium/648","questions/tags/字典树/medium/replace-words","questions/tags/哈希表/medium/replace-words"],"title_slug":"replace-words","question":"## [单词替换](https://leetcode-cn.com/problems/replace-words/)\n\n在英语中，我们有一个叫做 `词根`(root)的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 `继承词`(successor)。例如，词根`an`，跟随着单词 `other`(其他)，可以形成新的单词 `another`(另一个)。\n\n现在，给定一个由许多词根组成的词典和一个句子。你需要将句子中的所有`继承词`用`词根`替换掉。如果`继承词`有许多可以形成它的`词根`，则用最短的词根替换它。\n\n你需要输出替换之后的句子。\n\n \n\n**示例 1：**\n\n`**输入：**dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n**输出：**\"the cat was rat by the bat\"\n`\n\n**示例 2：**\n\n`**输入：**dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n**输出：**\"a a b c\"\n`\n\n**示例 3：**\n\n`**输入：**dictionary = [\"a\", \"aa\", \"aaa\", \"aaaa\"], sentence = \"a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa\"\n**输出：**\"a a a a a a a a bbb baba a\"\n`\n\n**示例 4：**\n\n`**输入：**dictionary = [\"catt\",\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n**输出：**\"the cat was rat by the bat\"\n`\n\n**示例 5：**\n\n`**输入：**dictionary = [\"ac\",\"ab\"], sentence = \"it is abnormal that this solution is accepted\"\n**输出：**\"it is ab that this solution is ac\"\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= dictionary.length \u003c= 1000`\n*   `1 \u003c= dictionary[i].length \u003c= 100`\n*   `dictionary[i]` 仅由小写字母组成。\n*   `1 \u003c= sentence.length \u003c= 10^6`\n*   `sentence` 仅由小写字母和空格组成。\n*   `sentence` 中单词的总量在范围 `[1, 1000]` 内。\n*   `sentence` 中每个单词的长度在范围 `[1, 1000]` 内。\n*   `sentence` 中单词之间由一个空格隔开。\n*   `sentence` 没有前导或尾随空格。"},"reverse-string":{"title":"Reverse String","translated_title":"反转字符串","question_id":"344","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/344","questions/tags/双指针/easy/reverse-string","questions/tags/字符串/easy/reverse-string"],"title_slug":"reverse-string","question":"## [反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。\n\n \n\n**示例 1：**\n\n`**输入：**[\"h\",\"e\",\"l\",\"l\",\"o\"]\n**输出：**[\"o\",\"l\",\"l\",\"e\",\"h\"]\n`\n\n**示例 2：**\n\n`**输入：**[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n**输出：**[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]`"},"reverse-words-in-a-string":{"title":"Reverse Words in a String","translated_title":"翻转字符串里的单词","question_id":"151","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"medium","save_dir":["questions/serial/medium/151","questions/tags/字符串/medium/reverse-words-in-a-string"],"title_slug":"reverse-words-in-a-string","question":"## [翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)\n\n给定一个字符串，逐个翻转字符串中的每个单词。\n\n**说明：**\n\n*   无空格字符构成一个 **单词** 。\n*   输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n*   如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n\n \n\n**示例 1：**\n\n`**输入：**\"`the sky is blue`\"\n**输出：**\"`blue is sky the`\"\n`\n\n**示例 2：**\n\n`**输入：**\"  hello world!  \"\n**输出：**\"world! hello\"\n**解释：**输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n`\n\n**示例 3：**\n\n`**输入：**\"a good   example\"\n**输出：**\"example good a\"\n**解释：**如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n`\n\n**示例 4：**\n\n`**输入：**s = \"  Bob    Loves  Alice   \"\n**输出：**\"Alice Loves Bob\"\n`\n\n**示例 5：**\n\n`**输入：**s = \"Alice does not even like bob\"\n**输出：**\"bob like even not does Alice\"\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= s.length \u003c= 10\n4\n`\n*   `s` 包含英文大小写字母、数字和空格 `' '`\n*   `s` 中 **至少存在一个** 单词\n\n \n\n**进阶：**\n\n*   请尝试使用 _O_(1) 额外空间复杂度的原地解法。"},"reverse-words-in-a-string-iii":{"title":"Reverse Words in a String III","translated_title":"反转字符串中的单词 III","question_id":"557","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/557","questions/tags/字符串/easy/reverse-words-in-a-string-iii"],"title_slug":"reverse-words-in-a-string-iii","question":"## [反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)\n\n给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。\n\n \n\n**示例：**\n\n`**输入：**\"Let's take LeetCode contest\"\n**输出：**\"s'teL ekat edoCteeL tsetnoc\"\n`\n\n \n\n**\n\n\n提示：**\n\n\n\n\n*   在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。"},"richest-customer-wealth":{"title":"Richest Customer Wealth","translated_title":"最富有客户的资产总量","question_id":"1791","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"easy","save_dir":["questions/serial/easy/1791","questions/tags/数组/easy/richest-customer-wealth"],"title_slug":"richest-customer-wealth","question":"## [最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)\n\n给你一个 `m x n` 的整数网格 `accounts` ，其中 `accounts[i][j]` 是第 `i​​​​​\n​​​​​​\n​` 位客户在第 `j` 家银行托管的资产数量。返回最富有客户所拥有的 **资产总量** 。\n\n客户的 **资产总量** 就是他们在各家银行托管的资产数量之和。最富有客户就是 **资产总量** 最大的客户。\n\n \n\n**示例 1：**\n\n`**输入：**accounts = [[1,2,3],[3,2,1]]\n**输出：**6\n**解释：**\n`第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n`两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n`\n\n**示例 2：**\n\n`**输入：**accounts = [[1,5],[7,3],[3,5]]\n**输出：**10\n**解释：**\n`第 1 位客户的资产总量` = 6\n`第 2 位客户的资产总量` = 10 \n`第 3 位客户的资产总量` = 8\n第 2 位客户是最富有的，资产总量是 10`\n\n**示例 3：**\n\n`**输入：**accounts = [[2,8,7],[7,1,3],[1,9,5]]\n**输出：**17\n`\n\n \n\n**提示：**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 \u003c= m, n \u003c= 50`\n*   `1 \u003c= accounts[i][j] \u003c= 100`"},"roman-to-integer":{"title":"Roman to Integer","translated_title":"罗马数字转整数","question_id":"13","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/13","questions/tags/数学/easy/roman-to-integer","questions/tags/字符串/easy/roman-to-integer"],"title_slug":"roman-to-integer","question":"## [罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)\n\n罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。\n\n`**字符**          **数值**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000`\n\n例如， 罗马数字 2 写做 `II` ，即为两个并列的 1。12 写做 `XII` ，即为 `X` + `II` 。 27 写做  `XXVII`, 即为 `XX` + `V` + `II` 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 `IIII`，而是 `IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 `IX`。这个特殊的规则只适用于以下六种情况：\n\n*   `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。\n*   `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。 \n*   `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n \n\n**示例 1:**\n\n`**输入:** \"III\"\n**输出:** 3`\n\n**示例 2:**\n\n`**输入:** \"IV\"\n**输出:** 4`\n\n**示例 3:**\n\n`**输入:** \"IX\"\n**输出:** 9`\n\n**示例 4:**\n\n`**输入:** \"LVIII\"\n**输出:** 58\n**解释:** L = 50, V= 5, III = 3.\n`\n\n**示例 5:**\n\n`**输入:** \"MCMXCIV\"\n**输出:** 1994\n**解释:** M = 1000, CM = 900, XC = 90, IV = 4.`\n\n \n\n**提示：**\n\n*   题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。\n*   IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。\n*   关于罗马数字的详尽书写规则，可以参考 [罗马数字 - Mathematics] (https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article)。"},"rotate-array":{"title":"Rotate Array","translated_title":"旋转数组","question_id":"189","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"medium","save_dir":["questions/serial/medium/189","questions/tags/数组/medium/rotate-array"],"title_slug":"rotate-array","question":"## [旋转数组](https://leetcode-cn.com/problems/rotate-array/)\n\n给定一个数组，将数组中的元素向右移动 _k _个位置，其中 _k _是非负数。\n\n**示例 1:**\n\n`**输入:** `[1,2,3,4,5,6,7]` 和 _k_ = 3\n**输出:** `[5,6,7,1,2,3,4]`\n**解释:**\n向右旋转 1 步: `[7,1,2,3,4,5,6]`\n向右旋转 2 步: `[6,7,1,2,3,4,5]\n`向右旋转 3 步: `[5,6,7,1,2,3,4]`\n`\n\n**示例 2:**\n\n`**输入:** `[-1,-100,3,99]` 和 _k_ = 2\n**输出:** [3,99,-1,-100]\n**解释:** \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]`\n\n**说明:**\n\n*   尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n*   要求使用空间复杂度为 O(1) 的 **原地 **算法。"},"score-after-flipping-matrix":{"title":"Score After Flipping Matrix","translated_title":"翻转矩阵后的得分","question_id":"891","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法"],"difficulty":"medium","save_dir":["questions/serial/medium/891","questions/tags/贪心算法/medium/score-after-flipping-matrix"],"title_slug":"score-after-flipping-matrix","question":"## [翻转矩阵后的得分](https://leetcode-cn.com/problems/score-after-flipping-matrix/)\n\n有一个二维矩阵 `A` 其中每个元素的值为 `0` 或 `1` 。\n\n移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 `0` 都更改为 `1`，将所有 `1` 都更改为 `0`。\n\n在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。\n\n返回尽可能高的分数。\n\n \n\n**示例：**\n\n`**输入：**[[0,0,1,1],[1,0,1,0],[1,1,0,0]]\n**输出：**39\n**解释：** 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]\n0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39`\n\n \n\n**提示：**\n\n1.  `1 \u003c= A.length \u003c= 20`\n2.  `1 \u003c= A[0].length \u003c= 20`\n3.  `A[i][j]` 是 `0` 或 `1`"},"search-a-2d-matrix-ii":{"title":"Search a 2D Matrix II","translated_title":"搜索二维矩阵 II","question_id":"240","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找","分治算法"],"difficulty":"medium","save_dir":["questions/serial/medium/240","questions/tags/二分查找/medium/search-a-2d-matrix-ii","questions/tags/分治算法/medium/search-a-2d-matrix-ii"],"title_slug":"search-a-2d-matrix-ii","question":"## [搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)\n\n编写一个高效的算法来搜索 `_m_ x _n_` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n\n*   每行的元素从左到右升序排列。\n*   每列的元素从上到下升序排列。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)\n`\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n**输出：**true\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)\n`\n**输入：**matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n**输出：**false\n`\n\n \n\n**提示：**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 \n9\n \n9\n`\n*   每行的所有元素从左到右升序排列\n*   每列的所有元素从上到下升序排列\n*   `-10\n9\n \n9\n`"},"search-in-a-binary-search-tree":{"title":"Search in a Binary Search Tree","translated_title":"二叉搜索树中的搜索","question_id":"783","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"easy","save_dir":["questions/serial/easy/783","questions/tags/树/easy/search-in-a-binary-search-tree"],"title_slug":"search-in-a-binary-search-tree","question":"## [二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n例如，\n\n`\n给定二叉搜索树:\n\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\n和值: 2\n`\n\n你应该返回如下子树:\n\n`\n      2     \n     / \\   \n    1   3\n`\n\n在上述示例中，如果要找的值是 `5`，但因为没有节点值为 `5`，我们应该返回 `NULL`。"},"search-in-rotated-sorted-array":{"title":"Search in Rotated Sorted Array","translated_title":"搜索旋转排序数组","question_id":"33","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"medium","save_dir":["questions/serial/medium/33","questions/tags/数组/medium/search-in-rotated-sorted-array","questions/tags/二分查找/medium/search-in-rotated-sorted-array"],"title_slug":"search-in-rotated-sorted-array","question":"## [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n给你一个整数数组 `nums` ，和一个整数 `target` 。\n\n该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` ）。\n\n请你在数组中搜索 `target` ，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 0\n**输出：**4\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 3\n**输出：**-1`\n\n**示例 3：**\n\n`\n**输入：**nums = [1], target = 0\n**输出：**-1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-10^4 \u003c= nums[i] \u003c= 10^4`\n*   `nums` 中的每个值都 **独一无二**\n*   `nums` 肯定会在某个点上旋转\n*   `-10^4 \u003c= target \u003c= 10^4`"},"search-insert-position":{"title":"Search Insert Position","translated_title":"搜索插入位置","question_id":"35","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/35","questions/tags/数组/easy/search-insert-position","questions/tags/二分查找/easy/search-insert-position"],"title_slug":"search-insert-position","question":"## [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n`**输入:** [1,3,5,6], 5\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** [1,3,5,6], 2\n**输出:** 1\n`\n\n**示例 3:**\n\n`**输入:** [1,3,5,6], 7\n**输出:** 4\n`\n\n**示例 4:**\n\n`**输入:** [1,3,5,6], 0\n**输出:** 0\n`"},"serialize-and-deserialize-binary-tree":{"title":"Serialize and Deserialize Binary Tree","translated_title":"二叉树的序列化与反序列化","question_id":"297","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","设计"],"difficulty":"hard","save_dir":["questions/serial/hard/297","questions/tags/树/hard/serialize-and-deserialize-binary-tree","questions/tags/设计/hard/serialize-and-deserialize-binary-tree"],"title_slug":"serialize-and-deserialize-binary-tree","question":"## [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)\n\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n**示例: **\n\n`你可以将以下二叉树：\n\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n\n序列化为 `\"[1,2,3,null,null,4,5]\"``\n\n**提示: **这与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n\n**说明: **不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。"},"shuffle-an-array":{"title":"Shuffle an Array","translated_title":"打乱数组","question_id":"384","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":null,"difficulty":"medium","save_dir":["questions/serial/medium/384"],"title_slug":"shuffle-an-array","question":"## [打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)\n\n给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。\n\n实现 `Solution` class:\n\n*   `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象\n*   `int[] reset()` 重设数组到它的初始状态并返回\n*   `int[] shuffle()` 返回数组随机打乱后的结果\n\n \n\n**示例：**\n\n`\n**输入**\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\n**输出**\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\n**解释**\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]\nsolution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]\nsolution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n`\n\n \n\n**提示：**\n\n*   `1 \n6\n \n6\n`\n*   `nums` 中的所有元素都是 **唯一的**\n*   最多可以调用 `5 * 10\n4\n` 次 `reset` 和 `shuffle`"},"single-number":{"title":"Single Number","translated_title":"只出现一次的数字","question_id":"136","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算","哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/136","questions/tags/位运算/easy/single-number","questions/tags/哈希表/easy/single-number"],"title_slug":"single-number","question":"## [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n`**输入:** [2,2,1]\n**输出:** 1\n`\n\n**示例 2:**\n\n`**输入:** [4,1,2,1,2]\n**输出:** 4`"},"sliding-window-maximum":{"title":"Sliding Window Maximum","translated_title":"滑动窗口最大值","question_id":"239","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆",""],"difficulty":"hard","save_dir":["questions/serial/hard/239","questions/tags/堆/hard/sliding-window-maximum","questions/tags/hard/sliding-window-maximum"],"title_slug":"sliding-window-maximum","question":"## [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)\n\n给定一个数组 _nums_，有一个大小为 _k _的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 _k_ 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n**进阶：**\n\n你能在线性时间复杂度内解决此题吗？\n\n \n\n**示例:**\n\n`**输入:** _nums_ = `[1,3,-1,-3,5,3,6,7]`, 和 _k_ = 3\n**输出:** `[3,3,5,5,6,7] \n**解释:** `\n  滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       **3**\n 1 [3  -1  -3] 5  3  6  7       **3**\n 1  3 [-1  -3  5] 3  6  7       **5**\n 1  3  -1 [-3  5  3] 6  7       **5**\n 1  3  -1  -3 [5  3  6] 7       **6**\n 1  3  -1  -3  5 [3  6  7]      **7**`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 10^5`\n*   `-10^4 \u003c= nums[i] \u003c= 10^4`\n*   `1 \u003c= k \u003c= nums.length`"},"sort-characters-by-frequency":{"title":"Sort Characters By Frequency","translated_title":"根据字符出现频率排序","question_id":"451","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","哈希表"],"difficulty":"medium","save_dir":["questions/serial/medium/451","questions/tags/堆/medium/sort-characters-by-frequency","questions/tags/哈希表/medium/sort-characters-by-frequency"],"title_slug":"sort-characters-by-frequency","question":"## [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n**示例 1:**\n\n`\n**输入:**\n\"tree\"\n\n**输出:**\n\"eert\"\n\n**解释:** 'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n`\n\n**示例 2:**\n\n`\n**输入:**\n\"cccaaa\"\n\n**输出:**\n\"cccaaa\"\n\n**解释:** 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n`\n\n**示例 3:**\n\n`\n**输入:**\n\"Aabb\"\n\n**输出:**\n\"bbAa\"\n\n**解释:** 此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n`"},"split-array-into-consecutive-subsequences":{"title":"Split Array into Consecutive Subsequences","translated_title":"分割数组为连续子序列","question_id":"659","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","贪心算法"],"difficulty":"medium","save_dir":["questions/serial/medium/659","questions/tags/堆/medium/split-array-into-consecutive-subsequences","questions/tags/贪心算法/medium/split-array-into-consecutive-subsequences"],"title_slug":"split-array-into-consecutive-subsequences","question":"## [分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)\n\n给你一个按升序排序的整数数组 `num`（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。\n\n如果可以完成上述分割，则返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n`**输入:** [1,2,3,3,4,5]\n**输出:** True\n**解释:**\n你可以分割出这样两个连续子序列 : \n1, 2, 3\n3, 4, 5\n`\n\n \n\n**示例 2：**\n\n`**输入:** [1,2,3,3,4,4,5,5]\n**输出:** True\n**解释:**\n你可以分割出这样两个连续子序列 : \n1, 2, 3, 4, 5\n3, 4, 5\n`\n\n \n\n**示例 3：**\n\n`**输入:** [1,2,3,4,4,5]\n**输出:** False\n`\n\n \n\n**提示：**\n\n1.  输入的数组长度范围为 [1, 10000]\n\n "},"split-array-into-fibonacci-sequence":{"title":"Split Array into Fibonacci Sequence","translated_title":"将数组拆分成斐波那契序列","question_id":"872","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","字符串","回溯算法"],"difficulty":"medium","save_dir":["questions/serial/medium/872","questions/tags/贪心算法/medium/split-array-into-fibonacci-sequence","questions/tags/字符串/medium/split-array-into-fibonacci-sequence","questions/tags/回溯算法/medium/split-array-into-fibonacci-sequence"],"title_slug":"split-array-into-fibonacci-sequence","question":"## [将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)\n\n给定一个数字字符串 `S`，比如 `S = \"123456579\"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]`。\n\n形式上，斐波那契式序列是一个非负整数列表 `F`，且满足：\n\n*   `0 \u003c= F[i] \u003c= 2^31 - 1`，（也就是说，每个整数都符合 32 位有符号整数类型）；\n*   `F.length \u003e= 3`；\n*   对于所有的`0 \u003c= i \u003c F.length - 2`，都有 `F[i] + F[i+1] = F[i+2]` 成立。\n\n另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。\n\n返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。\n\n \n\n**示例 1：**\n\n`**输入：**\"123456579\"\n**输出：**[123,456,579]\n`\n\n**示例 2：**\n\n`**输入:** \"11235813\"\n**输出:** [1,1,2,3,5,8,13]\n`\n\n**示例 3：**\n\n`**输入:** \"112358130\"\n**输出:** []\n**解释:** 这项任务无法完成。\n`\n\n**示例 4：**\n\n`**输入：**\"0123\"\n**输出：**[]\n**解释：**每个块的数字不能以零开头，因此 \"01\"，\"2\"，\"3\" 不是有效答案。\n`\n\n**示例 5：**\n\n`**输入:** \"1101111\"\n**输出:** [110, 1, 111]\n**解释:** 输出 [11,0,11,11] 也同样被接受。\n`\n\n \n\n**提示：**\n\n1.  `1 \u003c= S.length \u003c= 200`\n2.  字符串 `S` 中只含有数字。"},"sqrtx":{"title":"Sqrt(x)","translated_title":"x 的平方根","question_id":"69","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/69","questions/tags/数学/easy/sqrtx","questions/tags/二分查找/easy/sqrtx"],"title_slug":"sqrtx","question":"## [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n实现 `int sqrt(int x)` 函数。\n\n计算并返回 _x_ 的平方根，其中 _x_ 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n**示例 1:**\n\n`**输入:** 4\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** 8\n**输出:** 2\n**说明:** 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n`"},"swap-nodes-in-pairs":{"title":"Swap Nodes in Pairs","translated_title":"两两交换链表中的节点","question_id":"24","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"medium","save_dir":["questions/serial/medium/24","questions/tags/链表/medium/swap-nodes-in-pairs"],"title_slug":"swap-nodes-in-pairs","question":"## [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n`\n**输入：**head = [1,2,3,4]\n**输出：**[2,1,4,3]\n`\n\n**示例 2：**\n\n`\n**输入：**head = []\n**输出：**[]\n`\n\n**示例 3：**\n\n`\n**输入：**head = [1]\n**输出：**[1]\n`\n\n \n\n**提示：**\n\n*   链表中节点的数目在范围 `[0, 100]` 内\n*   `0 \u003c= Node.val \u003c= 100`"},"symmetric-tree":{"title":"Symmetric Tree","translated_title":"对称二叉树","question_id":"101","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索","广度优先搜索"],"difficulty":"easy","save_dir":["questions/serial/easy/101","questions/tags/树/easy/symmetric-tree","questions/tags/深度优先搜索/easy/symmetric-tree","questions/tags/广度优先搜索/easy/symmetric-tree"],"title_slug":"symmetric-tree","question":"## [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n`    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n`\n\n \n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n`    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n`\n\n \n\n**进阶：**\n\n你可以运用递归和迭代两种方法解决这个问题吗？"},"target-sum":{"title":"Target Sum","translated_title":"目标和","question_id":"494","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/494","questions/tags/深度优先搜索/medium/target-sum","questions/tags/动态规划/medium/target-sum"],"title_slug":"target-sum","question":"## [目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n \n\n**示例：**\n\n`**输入：**nums: [1, 1, 1, 1, 1], S: 3\n**输出：**5\n**解释：**\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n`\n\n \n\n**提示：**\n\n*   数组非空，且长度不会超过 20 。\n*   初始的数组的和不会超过 1000 。\n*   保证返回的最终结果能被 32 位整数存下。"},"task-scheduler":{"title":"Task Scheduler","translated_title":"任务调度器","question_id":"621","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","队列","数组"],"difficulty":"medium","save_dir":["questions/serial/medium/621","questions/tags/贪心算法/medium/task-scheduler","questions/tags/队列/medium/task-scheduler","questions/tags/数组/medium/task-scheduler"],"title_slug":"task-scheduler","question":"## [任务调度器](https://leetcode-cn.com/problems/task-scheduler/)\n\n给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。\n\n然而，两个 **相同种类** 的任务之间必须有长度为整数 **** `n` **** 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。\n\n你需要计算完成所有任务所需要的 **最短时间** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n**输出：**8\n**解释：**A -\u003e B -\u003e (待命) -\u003e A -\u003e B -\u003e (待命) -\u003e A -\u003e B\n     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 `\n\n**示例 2：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n**输出：**6\n**解释：**在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n诸如此类\n`\n\n**示例 3：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n**输出：**16\n**解释：**一种可能的解决方案是：\n     A -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e (待命) -\u003e (待命) -\u003e A -\u003e (待命) -\u003e (待命) -\u003e A\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `tasks[i]` 是大写英文字母\n*   `n` 的取值范围为 `[0, 100]`"},"top-k-frequent-elements":{"title":"Top K Frequent Elements","translated_title":"前 K 个高频元素","question_id":"347","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","哈希表"],"difficulty":"medium","save_dir":["questions/serial/medium/347","questions/tags/堆/medium/top-k-frequent-elements","questions/tags/哈希表/medium/top-k-frequent-elements"],"title_slug":"top-k-frequent-elements","question":"## [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n给定一个非空的整数数组，返回其中出现频率前 **_k _**高的元素。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,1,1,2,2,3], k = 2\n**输出:** [1,2]\n`\n\n**示例 2:**\n\n`**输入:** nums = [1], k = 1\n**输出:** [1]`\n\n \n\n**提示：**\n\n*   你可以假设给定的 _k _总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n*   你的算法的时间复杂度**必须**优于 O(_n_ log _n_) , _n _是数组的大小。\n*   题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n*   你可以按任意顺序返回答案。"},"two-sum-ii-input-array-is-sorted":{"title":"Two Sum II - Input array is sorted","translated_title":"两数之和 II - 输入有序数组","question_id":"167","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/167","questions/tags/数组/easy/two-sum-ii-input-array-is-sorted","questions/tags/双指针/easy/two-sum-ii-input-array-is-sorted","questions/tags/二分查找/easy/two-sum-ii-input-array-is-sorted"],"title_slug":"two-sum-ii-input-array-is-sorted","question":"## [两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)\n\n给定一个已按照**_升序排列_ **的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 __ index1 和 index2，其中 index1 必须小于 index2_。_\n\n**说明:**\n\n*   返回的下标值（index1 和 index2）不是从零开始的。\n*   你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n**示例:**\n\n`**输入:** numbers = [2, 7, 11, 15], target = 9\n**输出:** [1,2]\n**解释:** 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。`"},"unique-binary-search-trees-ii":{"title":"Unique Binary Search Trees II","translated_title":"不同的二叉搜索树 II","question_id":"95","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/95","questions/tags/树/medium/unique-binary-search-trees-ii","questions/tags/动态规划/medium/unique-binary-search-trees-ii"],"title_slug":"unique-binary-search-trees-ii","question":"## [不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 _n_，生成所有由 1 ... _n_ 为节点所组成的 **二叉搜索树** 。\n\n \n\n**示例：**\n\n`**输入：**3\n**输出：**\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n**解释：**\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 8`"},"unique-paths":{"title":"Unique Paths","translated_title":"不同路径","question_id":"62","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/62","questions/tags/数组/medium/unique-paths","questions/tags/动态规划/medium/unique-paths"],"title_slug":"unique-paths","question":"## [不同路径](https://leetcode-cn.com/problems/unique-paths/)\n\n一个机器人位于一个 _m x n_ 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)\n\n\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\n\n\n \n\n**示例 1:**\n\n`**输入:** m = 3, n = 2\n**输出:** 3\n**解释:**\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -\u003e 向右 -\u003e 向下\n2. 向右 -\u003e 向下 -\u003e 向右\n3. 向下 -\u003e 向右 -\u003e 向右\n`\n\n**示例 2:**\n\n`**输入:** m = 7, n = 3\n**输出:** 28`\n\n \n\n**提示：**\n\n*   `1 \u003c= m, n \u003c= 100`\n*   题目数据保证答案小于等于 `2 * 10 ^ 9`"},"valid-anagram":{"title":"Valid Anagram","translated_title":"有效的字母异位词","question_id":"242","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表"],"difficulty":"easy","save_dir":["questions/serial/easy/242","questions/tags/排序/easy/valid-anagram","questions/tags/哈希表/easy/valid-anagram"],"title_slug":"valid-anagram","question":"## [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)\n\n给定两个字符串 _s_ 和 _t_ ，编写一个函数来判断 _t_ 是否是 _s_ 的字母异位词。\n\n**示例 1:**\n\n`**输入:** _s_ = \"anagram\", _t_ = \"nagaram\"\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** _s_ = \"rat\", _t_ = \"car\"\n**输出:** false`\n\n**说明:**  \n\n你可以假设字符串只包含小写字母。\n\n**进阶:**  \n\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？"},"valid-palindrome":{"title":"Valid Palindrome","translated_title":"验证回文串","question_id":"125","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/125","questions/tags/双指针/easy/valid-palindrome","questions/tags/字符串/easy/valid-palindrome"],"title_slug":"valid-palindrome","question":"## [验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n**说明：**本题中，我们将空字符串定义为有效的回文串。\n\n**示例 1:**\n\n`**输入:** \"A man, a plan, a canal: Panama\"\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** \"race a car\"\n**输出:** false\n`"},"valid-parentheses":{"title":"Valid Parentheses","translated_title":"有效的括号","question_id":"20","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","字符串"],"difficulty":"easy","save_dir":["questions/serial/easy/20","questions/tags/栈/easy/valid-parentheses","questions/tags/字符串/easy/valid-parentheses"],"title_slug":"valid-parentheses","question":"## [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n1.  左括号必须用相同类型的右括号闭合。\n2.  左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\n**示例 1:**\n\n`**输入:** \"()\"\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** \"()[]{}\"\n**输出:** true\n`\n\n**示例 3:**\n\n`**输入:** \"(]\"\n**输出:** false\n`\n\n**示例 4:**\n\n`**输入:** \"([)]\"\n**输出:** false\n`\n\n**示例 5:**\n\n`**输入:** \"{[]}\"\n**输出:** true`"},"valid-perfect-square":{"title":"Valid Perfect Square","translated_title":"有效的完全平方数","question_id":"367","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"easy","save_dir":["questions/serial/easy/367","questions/tags/数学/easy/valid-perfect-square","questions/tags/二分查找/easy/valid-perfect-square"],"title_slug":"valid-perfect-square","question":"## [有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n给定一个正整数 _num_，编写一个函数，如果 _num_ 是一个完全平方数，则返回 True，否则返回 False。\n\n**说明：**不要使用任何内置的库函数，如  `sqrt`。\n\n**示例 1：**\n\n`**输入：**16\n**输出：**True`\n\n**示例 2：**\n\n`**输入：**14\n**输出：**False\n`"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","translated_title":"验证二叉搜索树","question_id":"98","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"medium","save_dir":["questions/serial/medium/98","questions/tags/树/medium/validate-binary-search-tree","questions/tags/深度优先搜索/medium/validate-binary-search-tree"],"title_slug":"validate-binary-search-tree","question":"## [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n*   节点的左子树只包含**小于**当前节点的数。\n*   节点的右子树只包含**大于**当前节点的数。\n*   所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n`**输入:**\n    2\n   / \\\n  1   3\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:**     5\n   / \\\n  1   4\n     / \\\n    3   6\n**输出:** false\n**解释:** 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n`"},"wiggle-subsequence":{"title":"Wiggle Subsequence","translated_title":"摆动序列","question_id":"376","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/376","questions/tags/贪心算法/medium/wiggle-subsequence","questions/tags/动态规划/medium/wiggle-subsequence"],"title_slug":"wiggle-subsequence","question":"## [摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n\n例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n\n**示例 1:**\n\n`**输入:** [1,7,4,9,2,5]\n**输出:** 6 \n**解释:** 整个序列均为摆动序列。\n`\n\n**示例 2:**\n\n`**输入:** [1,17,5,10,13,15,10,5,16,8]\n**输出:** 7\n**解释:** 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。`\n\n**示例 3:**\n\n`**输入:** [1,2,3,4,5,6,7,8,9]\n**输出:** 2`\n\n**进阶:**  \n\n你能否用 O(_n_) 时间复杂度完成此题?"},"word-break":{"title":"Word Break","translated_title":"单词拆分","question_id":"139","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["动态规划"],"difficulty":"medium","save_dir":["questions/serial/medium/139","questions/tags/动态规划/medium/word-break"],"title_slug":"word-break","question":"## [单词拆分](https://leetcode-cn.com/problems/word-break/)\n\n给定一个**非空**字符串 _s_ 和一个包含**非空**单词的列表 _wordDict_，判定 _s_ 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n**说明：**\n\n*   拆分时可以重复使用字典中的单词。\n*   你可以假设字典中没有重复的单词。\n\n**示例 1：**\n\n`**输入:** s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n**输出:** true\n**解释:** 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n`\n\n**示例 2：**\n\n`**输入:** s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n**输出:** true\n**解释:** 返回 true 因为 `\"`applepenapple`\"` 可以被拆分成 `\"`apple pen apple`\"`。\n     注意你可以重复使用字典中的单词。\n`\n\n**示例 3：**\n\n`**输入:** s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n**输出:** false\n`"},"word-search-ii":{"title":"Word Search II","translated_title":"单词搜索 II","question_id":"212","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字典树","回溯算法"],"difficulty":"hard","save_dir":["questions/serial/hard/212","questions/tags/字典树/hard/word-search-ii","questions/tags/回溯算法/hard/word-search-ii"],"title_slug":"word-search-ii","question":"## [单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)\n\n给定一个 `m x n` 二维字符网格 `board`****和一个单词（字符串）列表 `words`，找出所有同时在二维网格和字典中出现的单词。\n\n单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\n`\n**输入：**board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n**输出：**[\"eat\",\"oath\"]\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\n`\n**输入：**board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n**输出：**[]\n`\n\n \n\n**提示：**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 \n4\n`\n*   `1 \u003c= words[i].length \u003c= 10`\n*   `words[i]` 由小写英文字母组成\n*   `words` 中的所有字符串互不相同"},"zero-matrix-lcci":{"title":"Zero Matrix LCCI","translated_title":"零矩阵","question_id":"100186","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"medium","save_dir":["questions/serial/medium/100186","questions/tags/数组/medium/zero-matrix-lcci"],"title_slug":"zero-matrix-lcci","question":"## [零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)\n\n编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。\n\n \n\n**示例 1：**\n\n`**输入：**\n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n**输出：**\n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n`\n\n**示例 2：**\n\n`**输入：**\n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n**输出：**\n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n`"}}