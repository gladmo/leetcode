{"":{"title":"","translated_title":"","question_id":"","language":null,"tags":null,"difficulty":"","save_dir":["questions/serial"],"title_slug":"","question":"## [](https://leetcode-cn.com/problems//)\n\n"},"01-matrix":{"title":"01 Matrix","translated_title":"01 矩阵","question_id":"542","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","广度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/542","questions/tags/深度优先搜索/中等/01-matrix","questions/tags/广度优先搜索/中等/01-matrix"],"title_slug":"01-matrix","question":"## [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n \n\n**示例 1：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n`\n\n**示例 2：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n`\n\n \n\n**提示：**\n\n*   给定矩阵的元素个数不超过 10000。\n*   给定矩阵中至少有一个元素是 0。\n*   矩阵中的元素只在四个方向上相邻: 上、下、左、右。"},"3sum":{"title":"3Sum","translated_title":"三数之和","question_id":"15","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","双指针"],"difficulty":"中等","save_dir":["questions/serial/中等/15","questions/tags/数组/中等/3sum","questions/tags/双指针/中等/3sum"],"title_slug":"3sum","question":"## [三数之和](https://leetcode-cn.com/problems/3sum/)\n\n给你一个包含 _n_ 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 _a，b，c ，_使得 _a + b + c =_ 0 ？请你找出所有满足条件且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n \n\n**示例：**\n\n`给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n\n满足要求的三元组集合为：\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]\n`"},"4sum":{"title":"4Sum","translated_title":"四数之和","question_id":"18","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表","双指针"],"difficulty":"中等","save_dir":["questions/serial/中等/18","questions/tags/数组/中等/4sum","questions/tags/哈希表/中等/4sum","questions/tags/双指针/中等/4sum"],"title_slug":"4sum","question":"## [四数之和](https://leetcode-cn.com/problems/4sum/)\n\n给定一个包含 _n_ 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 _a，__b，c_ 和 _d_ ，使得 _a_ + _b_ + _c_ + _d_ 的值与 `target` 相等？找出所有满足条件且不重复的四元组。\n\n**注意：**\n\n答案中不可以包含重复的四元组。\n\n**示例：**\n\n`给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。\n\n满足要求的四元组集合为：\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]\n`"},"4sum-ii":{"title":"4Sum II","translated_title":"四数相加 II","question_id":"454","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/454","questions/tags/哈希表/中等/4sum-ii","questions/tags/二分查找/中等/4sum-ii"],"title_slug":"4sum-ii","question":"## [四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)\n\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 `(i, j, k, l)` ，使得 `A[i] + B[j] + C[k] + D[l] = 0`。\n\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2\n28\n 到 2\n28\n - 1 之间，最终结果不会超过 2\n31\n - 1 。\n\n**例如:**\n\n`\n**输入:**\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n**输出:**\n2\n\n**解释:**\n两个元组如下:\n1. (0, 0, 0, 1) -\u003e A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -\u003e A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n`"},"balanced-binary-tree":{"title":"Balanced Binary Tree","translated_title":"平衡二叉树","question_id":"110","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/110","questions/tags/树/简单/balanced-binary-tree","questions/tags/深度优先搜索/简单/balanced-binary-tree"],"title_slug":"balanced-binary-tree","question":"## [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n\u003e 一个二叉树_每个节点_的左右两个子树的高度差的绝对值不超过 1 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n`\n**输入：**root = [3,9,20,null,null,15,7]\n**输出：**true\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n`\n**输入：**root = [1,2,2,3,3,null,null,4,4]\n**输出：**false\n`\n\n**示例 3：**\n\n`\n**输入：**root = []\n**输出：**true\n`\n\n \n\n**提示：**\n\n*   树中的节点数在范围 `[0, 5000]` 内\n*   `-10\n4\n \n4\n`"},"binary-search":{"title":"Binary Search","translated_title":"二分查找","question_id":"792","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/792","questions/tags/二分查找/简单/binary-search"],"title_slug":"binary-search","question":"## [二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 9\n**输出:** 4\n**解释:** 9 出现在 `nums` 中并且下标为 4\n`\n\n**示例 2:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 2\n**输出:** -1\n**解释:** 2 不存在 `nums` 中因此返回 -1\n`\n\n \n\n**提示：**\n\n1.  你可以假设 `nums` 中的所有元素是不重复的。\n2.  `n` 将在 `[1, 10000]`之间。\n3.  `nums` 的每个元素都将在 `[-9999, 9999]`之间。"},"binary-search-tree-iterator":{"title":"Binary Search Tree Iterator","translated_title":"二叉搜索树迭代器","question_id":"173","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","树","设计"],"difficulty":"中等","save_dir":["questions/serial/中等/173","questions/tags/栈/中等/binary-search-tree-iterator","questions/tags/树/中等/binary-search-tree-iterator","questions/tags/设计/中等/binary-search-tree-iterator"],"title_slug":"binary-search-tree-iterator","question":"## [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n \n\n**示例：**\n\n**![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/25/bst-tree.png)**\n\n`BSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false`\n\n \n\n**提示：**\n\n*   `next()` 和 `hasNext()` 操作的时间复杂度是 O(1)，并使用 O(_h_) 内存，其中 _h _是树的高度。\n*   你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 中至少存在一个下一个最小的数。"},"climbing-stairs":{"title":"Climbing Stairs","translated_title":"爬楼梯","question_id":"70","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["动态规划"],"difficulty":"简单","save_dir":["questions/serial/简单/70","questions/tags/动态规划/简单/climbing-stairs"],"title_slug":"climbing-stairs","question":"## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 _n_ 是一个正整数。\n\n**示例 1：**\n\n`**输入：** 2\n**输出：** 2\n**解释：** 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶`\n\n**示例 2：**\n\n`**输入：** 3\n**输出：** 3\n**解释：** 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n`"},"clone-graph":{"title":"Clone Graph","translated_title":"克隆图","question_id":"133","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["深度优先搜索","广度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/133","questions/tags/深度优先搜索/中等/clone-graph","questions/tags/广度优先搜索/中等/clone-graph","questions/tags/图/中等/clone-graph"],"title_slug":"clone-graph","question":"## [克隆图](https://leetcode-cn.com/problems/clone-graph/)\n\n给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin) **图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。\n\n图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。\n\n`class Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n}`\n\n \n\n**测试用例格式：**\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。\n\n**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝 **作为对克隆图的引用返回。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)\n\n`**输入：**adjList = [[2,4],[1,3],[2,4],[1,3]]\n**输出：**[[2,4],[1,3],[2,4],[1,3]]\n**解释：** 图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)\n\n`**输入：**adjList = [[]]\n**输出：**[[]]\n**解释：**输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n`\n\n**示例 3：**\n\n`**输入：**adjList = []\n**输出：**[]\n**解释：**这个图是空的，它不含任何节点。\n`\n\n**示例 4：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)\n\n`**输入：**adjList = [[2],[1]]\n**输出：**[[2],[1]]`\n\n \n\n**提示：**\n\n1.  节点数不超过 100 。\n2.  每个节点值 `Node.val` 都是唯一的，`1 \u003c= Node.val \u003c= 100`。\n3.  无向图是一个[简单图](https://baike.baidu.com/item/简单图/1680528?fr=aladdin)，这意味着图中没有重复的边，也没有自环。\n4.  由于图是无向的，如果节点 _p_ 是节点 _q_ 的邻居，那么节点 _q_ 也必须是节点 _p_ 的邻居。\n5.  图是连通图，你可以从给定节点访问到所有节点。"},"contains-duplicate":{"title":"Contains Duplicate","translated_title":"存在重复元素","question_id":"217","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/217","questions/tags/数组/简单/contains-duplicate","questions/tags/哈希表/简单/contains-duplicate"],"title_slug":"contains-duplicate","question":"## [存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。\n\n \n\n**示例 1:**\n\n`**输入:** [1,2,3,1]\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** [1,2,3,4]\n**输出:** false`\n\n**示例 3:**\n\n`**输入:** [1,1,1,3,3,4,3,2,4,2]\n**输出:** true`"},"contains-duplicate-ii":{"title":"Contains Duplicate II","translated_title":"存在重复元素 II","question_id":"219","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/219","questions/tags/数组/简单/contains-duplicate-ii","questions/tags/哈希表/简单/contains-duplicate-ii"],"title_slug":"contains-duplicate-ii","question":"## [存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)\n\n给定一个整数数组和一个整数 _k_，判断数组中是否存在两个不同的索引_ i_ 和_ j_，使得 **nums [i] = nums [j]**，并且 _i_ 和 _j_ 的差的 **绝对值** 至多为 _k_。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,2,3,1], k __ = 3\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** nums = [1,0,1,1], k __ = __ 1\n**输出:** true`\n\n**示例 3:**\n\n`**输入:** nums = [1,2,3,1,2,3], k __ = __ 2\n**输出:** false`"},"contains-duplicate-iii":{"title":"Contains Duplicate III","translated_title":"存在重复元素 III","question_id":"220","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序",""],"difficulty":"中等","save_dir":["questions/serial/中等/220","questions/tags/排序/中等/contains-duplicate-iii","questions/tags/中等/contains-duplicate-iii"],"title_slug":"contains-duplicate-iii","question":"## [存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n在整数数组 `nums` 中，是否存在两个下标 **_i_** 和 **_j_**，使得 **nums [i]** 和 **nums [j]** 的差的绝对值小于等于 _**t**_ ，且满足 **_i_** 和 **_j_** 的差的绝对值也小于等于 _**ķ**_ 。\n\n如果存在则返回 `true`，不存在返回 `false`。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,2,3,1], k __ = 3, t = 0\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** nums = [1,0,1,1], k __ = __ 1, t = 2\n**输出:** true`\n\n**示例 3:**\n\n`**输入:** nums = [1,5,9,1,5,9], k = 2, t = 3\n**输出:** false`"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","translated_title":"完全二叉树的节点个数","question_id":"222","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/222","questions/tags/树/中等/count-complete-tree-nodes","questions/tags/二分查找/中等/count-complete-tree-nodes"],"title_slug":"count-complete-tree-nodes","question":"## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2\nh\n 个节点。\n\n**示例:**\n\n`**输入:** \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n**输出:** 6`"},"count-primes":{"title":"Count Primes","translated_title":"计数质数","question_id":"204","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","数学"],"difficulty":"简单","save_dir":["questions/serial/简单/204","questions/tags/哈希表/简单/count-primes","questions/tags/数学/简单/count-primes"],"title_slug":"count-primes","question":"## [计数质数](https://leetcode-cn.com/problems/count-primes/)\n\n统计所有小于非负整数 _`n` _的质数的数量。\n\n \n\n**示例 1：**\n\n`**输入：**n = 10\n**输出：**4\n**解释：**小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n`\n\n**示例 2：**\n\n`**输入：**n = 0\n**输出：**0\n`\n\n**示例 3：**\n\n`**输入：**n = 1\n**输出**：0\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 5 * 10\n6\n`"},"create-maximum-number":{"title":"Create Maximum Number","translated_title":"拼接最大数","question_id":"321","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","动态规划"],"difficulty":"困难","save_dir":["questions/serial/困难/321","questions/tags/贪心算法/困难/create-maximum-number","questions/tags/动态规划/困难/create-maximum-number"],"title_slug":"create-maximum-number","question":"## [拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)\n\n给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k \u003c= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。\n\n求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。\n\n**说明:** 请尽可能地优化你算法的时间和空间复杂度。\n\n**示例 1:**\n\n`**输入:**\nnums1 = `[3, 4, 6, 5]`\nnums2 = `[9, 1, 2, 5, 8, 3]`\nk = `5`\n**输出:**\n`[9, 8, 6, 5, 3]``\n\n**示例 2:**\n\n`**输入:**\nnums1 = `[6, 7]`\nnums2 = `[6, 0, 4]`\nk = `5`\n**输出:**\n`[6, 7, 6, 0, 4]``\n\n**示例 3:**\n\n`**输入:**\nnums1 = `[3, 9]`\nnums2 = `[8, 9]`\nk = `3`\n**输出:**\n`[9, 8, 9]``"},"decode-string":{"title":"Decode String","translated_title":"字符串解码","question_id":"394","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/394","questions/tags/栈/中等/decode-string","questions/tags/深度优先搜索/中等/decode-string"],"title_slug":"decode-string","question":"## [字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 _encoded_string_ 正好重复 _k_ 次。注意 _k_ 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 _k_ ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n`**输入：**s = \"3[a]2[bc]\"\n**输出：**\"aaabcbc\"\n`\n\n**示例 2：**\n\n`**输入：**s = \"3[a2[c]]\"\n**输出：**\"accaccacc\"\n`\n\n**示例 3：**\n\n`**输入：**s = \"2[abc]3[cd]ef\"\n**输出：**\"abcabccdcdcdef\"\n`\n\n**示例 4：**\n\n`**输入：**s = \"abc3[cd]xyz\"\n**输出：**\"abccdcdcdxyz\"\n`"},"delete-node-in-a-bst":{"title":"Delete Node in a BST","translated_title":"删除二叉搜索树中的节点","question_id":"450","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"中等","save_dir":["questions/serial/中等/450","questions/tags/树/中等/delete-node-in-a-bst"],"title_slug":"delete-node-in-a-bst","question":"## [删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n\n给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n1.  首先找到需要删除的节点；\n2.  如果找到了，删除它。\n\n**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n**示例:**\n\n`\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n`"},"design-hashset":{"title":"Design HashSet","translated_title":"设计哈希集合","question_id":"816","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/816","questions/tags/设计/简单/design-hashset","questions/tags/哈希表/简单/design-hashset"],"title_slug":"design-hashset","question":"## [设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)\n\n不使用任何内建的哈希表库设计一个哈希集合\n\n具体地说，你的设计应该包含以下的功能\n\n*   `add(value)`：向哈希集合中插入一个值。\n*   `contains(value)` ：返回哈希集合中是否存在这个值。\n*   `remove(value)`：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。\n\n**示例:**\n\n`MyHashSet hashSet = new MyHashSet();\nhashSet.add(1);         \nhashSet.add(2);         \nhashSet.contains(1);    // 返回 true\nhashSet.contains(3);    // 返回 false (未找到)\nhashSet.add(2);          \nhashSet.contains(2);    // 返回 true\nhashSet.remove(2);          \nhashSet.contains(2);    // 返回  false (已经被删除)\n`\n\n**注意：**\n\n*   所有的值都在 `[0, 1000000]`的范围内。\n*   操作的总数目在`[1, 10000]`范围内。\n*   不要使用内建的哈希集合库。"},"fibonacci-number":{"title":"Fibonacci Number","translated_title":"斐波那契数","question_id":"1013","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/1013","questions/tags/数组/简单/fibonacci-number"],"title_slug":"fibonacci-number","question":"## [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)\n\n**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n`F(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1.\n`\n\n给定 `N`，计算 `F(N)`。\n\n \n\n**示例 1：**\n\n`**输入：**2\n**输出：**1\n**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1.\n`\n\n**示例 2：**\n\n`**输入：**3\n**输出：**2\n**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2.\n`\n\n**示例 3：**\n\n`**输入：**4\n**输出：**3\n**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3.\n`\n\n \n\n**提示：**\n\n*   0 ≤ `N` ≤ 30"},"find-first-and-last-position-of-element-in-sorted-array":{"title":"Find First and Last Position of Element in Sorted Array","translated_title":"在排序数组中查找元素的第一个和最后一个位置","question_id":"34","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/34","questions/tags/数组/中等/find-first-and-last-position-of-element-in-sorted-array","questions/tags/二分查找/中等/find-first-and-last-position-of-element-in-sorted-array"],"title_slug":"find-first-and-last-position-of-element-in-sorted-array","question":"## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n\n**进阶：**\n\n*   你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 8\n**输出：**[3,4]`\n\n**示例 2：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 6\n**输出：**[-1,-1]`\n\n**示例 3：**\n\n`\n**输入：**nums = [], target = 0\n**输出：**[-1,-1]`\n\n \n\n**提示：**\n\n*   `0 \u003c= nums.length \u003c= 105`\n*   `-109 \u003c= nums[i] \u003c= 109`\n*   `nums` 是一个非递减数组\n*   `-109 \u003c= target \u003c= 109`"},"find-k-closest-elements":{"title":"Find K Closest Elements","translated_title":"找到 K 个最接近的元素","question_id":"658","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/658","questions/tags/二分查找/中等/find-k-closest-elements"],"title_slug":"find-k-closest-elements","question":"## [找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)\n\n给定一个排序好的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。\n\n整数 `a` 比整数 `b` 更接近 `x` 需要满足：\n\n*   `|a - x| \n4\n`\n*   数组里的每个元素与 `x` 的绝对值不超过 `10\n4\n`"},"find-minimum-in-rotated-sorted-array":{"title":"Find Minimum in Rotated Sorted Array","translated_title":"寻找旋转排序数组中的最小值","question_id":"153","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/153","questions/tags/数组/中等/find-minimum-in-rotated-sorted-array","questions/tags/二分查找/中等/find-minimum-in-rotated-sorted-array"],"title_slug":"find-minimum-in-rotated-sorted-array","question":"## [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 `[0,1,2,4,5,6,7]`  **** 可能变为 `[4,5,6,7,0,1,2]` 。\n\n请找出其中最小的元素。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [3,4,5,1,2]\n**输出：**1\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [4,5,6,7,0,1,2]\n**输出：**0\n`\n\n**示例 3：**\n\n`\n**输入：**nums = [1]\n**输出：**1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-5000 \u003c= nums[i] \u003c= 5000`\n*   `nums` 中的所有整数都是 **唯一** 的\n*   `nums` 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转"},"find-peak-element":{"title":"Find Peak Element","translated_title":"寻找峰值","question_id":"162","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/162","questions/tags/数组/中等/find-peak-element","questions/tags/二分查找/中等/find-peak-element"],"title_slug":"find-peak-element","question":"## [寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。\n\n数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。\n\n你可以假设 `nums[-1] = nums[n] = -∞`。\n\n**示例 1:**\n\n`**输入:** **nums** = `[1,2,3,1]`\n**输出:** 2\n**解释:** 3 是峰值元素，你的函数应该返回其索引 2。`\n\n**示例 2:**\n\n`**输入:** **nums** = `[`1,2,1,3,5,6,4]\n**输出:** 1 或 5 \n**解释:** 你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n`\n\n**说明:**\n\n你的解法应该是 _O_(_logN_)_ _时间复杂度的。"},"find-pivot-index":{"title":"Find Pivot Index","translated_title":"寻找数组的中心索引","question_id":"724","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/724","questions/tags/数组/简单/find-pivot-index"],"title_slug":"find-pivot-index","question":"## [寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)\n\n给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。\n\n我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n \n\n**示例 1：**\n\n`**输入：**\nnums = [1, 7, 3, 6, 5, 6]\n**输出：**3\n**解释：**\n索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。\n同时, 3 也是第一个符合要求的中心索引。\n`\n\n**示例 2：**\n\n`**输入：**\nnums = [1, 2, 3]\n**输出：**-1\n**解释：**\n数组中不存在满足此条件的中心索引。`\n\n \n\n**说明：**\n\n*   `nums` 的长度范围为 `[0, 10000]`。\n*   任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。"},"find-smallest-letter-greater-than-target":{"title":"Find Smallest Letter Greater Than Target","translated_title":"寻找比目标字母大的最小字母","question_id":"745","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/745","questions/tags/二分查找/简单/find-smallest-letter-greater-than-target"],"title_slug":"find-smallest-letter-greater-than-target","question":"## [寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)\n\n给你一个排序后的字符列表 `letters` ，列表中只包含小写英文字母。另给出一个目标字母 `target`，请你寻找在这一有序列表里比目标字母大的最小字母。\n\n在比较时，字母是依序循环出现的。举个例子：\n\n*   如果目标字母 `target = 'z'` 并且字符列表为 `letters = ['a', 'b']`，则答案返回 `'a'`\n\n \n\n**示例：**\n\n`**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"a\"\n**输出:** \"c\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"c\"\n**输出:** \"f\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"d\"\n**输出:** \"f\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"g\"\n**输出:** \"j\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"j\"\n**输出:** \"c\"\n\n**输入:**\nletters = [\"c\", \"f\", \"j\"]\ntarget = \"k\"\n**输出:** \"c\"\n`\n\n \n\n**提示：**\n\n1.  `letters`长度范围在`[2, 10000]`区间内。\n2.  `letters` 仅由小写字母组成，最少包含两个不同的字母。\n3.  目标字母`target` 是一个小写字母。"},"first-bad-version":{"title":"First Bad Version","translated_title":"第一个错误的版本","question_id":"278","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/278","questions/tags/二分查找/简单/first-bad-version"],"title_slug":"first-bad-version","question":"## [第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n**示例:**\n\n`给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n`调用 isBadVersion(3) -\u003e false\n调用 isBadVersion(5) -\u003e true\n调用 isBadVersion(4) -\u003e true\n\n所以，4 是第一个错误的版本。 ``"},"first-unique-character-in-a-string":{"title":"First Unique Character in a String","translated_title":"字符串中的第一个唯一字符","question_id":"387","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/387","questions/tags/哈希表/简单/first-unique-character-in-a-string","questions/tags/字符串/简单/first-unique-character-in-a-string"],"title_slug":"first-unique-character-in-a-string","question":"## [字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n \n\n**示例：**\n\n`s = \"leetcode\"\n返回 0\n\ns = \"loveleetcode\"\n返回 2\n`\n\n \n\n**提示：**你可以假定该字符串只包含小写字母。"},"flood-fill":{"title":"Flood Fill","translated_title":"图像渲染","question_id":"733","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/733","questions/tags/深度优先搜索/简单/flood-fill"],"title_slug":"flood-fill","question":"## [图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n`\n**输入:** \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n**输出:** [[2,2,2],[2,2,0],[2,0,1]]\n**解析:** \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n`\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 \u003c= sr \u003c image.length` 和 `0 \u003c= sc \u003c image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。"},"group-anagrams":{"title":"Group Anagrams","translated_title":"字母异位词分组","question_id":"49","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","字符串"],"difficulty":"中等","save_dir":["questions/serial/中等/49","questions/tags/哈希表/中等/group-anagrams","questions/tags/字符串/中等/group-anagrams"],"title_slug":"group-anagrams","question":"## [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)\n\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n**示例:**\n\n`**输入:** `[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]`\n**输出:**\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]`\n\n**说明：**\n\n*   所有输入均为小写字母。\n*   不考虑答案输出的顺序。"},"guess-number-higher-or-lower":{"title":"Guess Number Higher or Lower","translated_title":"猜数字大小","question_id":"374","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/374","questions/tags/二分查找/简单/guess-number-higher-or-lower"],"title_slug":"guess-number-higher-or-lower","question":"## [猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)\n\n猜数字游戏的规则如下：\n\n*   每轮游戏，我都会从 **1** 到 _**n**_ 随机选择一个数字。 请你猜选出的是哪个数字。\n*   如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有 3 种可能的情况（`-1`，`1` 或 `0`）：\n\n*   -1：我选出的数字比你猜的数字小 `pick \n num`\n*   0：我选出的数字和你猜的数字一样。恭喜！你猜对了！`pick == num`\n\n \n\n**示例 1：**\n\n`\n**输入：**n = 10, pick = 6\n**输出：**6\n`\n\n**示例 2：**\n\n`\n**输入：**n = 1, pick = 1\n**输出：**1\n`\n\n**示例 3：**\n\n`\n**输入：**n = 2, pick = 1\n**输出：**1\n`\n\n**示例 4：**\n\n`\n**输入：**n = 2, pick = 2\n**输出：**2\n`\n\n \n\n**提示：**\n\n*   `1 \n31\n - 1`\n*   `1 \u003c= pick \u003c= n`"},"happy-number":{"title":"Happy Number","translated_title":"快乐数","question_id":"202","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","数学"],"difficulty":"简单","save_dir":["questions/serial/简单/202","questions/tags/哈希表/简单/happy-number","questions/tags/数学/简单/happy-number"],"title_slug":"happy-number","question":"## [快乐数](https://leetcode-cn.com/problems/happy-number/)\n\n编写一个算法来判断一个数 `n` 是不是快乐数。\n\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。如果 **可以变为**  1，那么这个数就是快乐数。\n\n如果 `n` 是快乐数就返回 `True` ；不是，则返回 `False` 。\n\n \n\n**示例：**\n\n`**输入：**19\n**输出：**true\n**解释：** 1\n2\n + 9\n2\n = 82\n8\n2\n + 2\n2\n = 68\n6\n2\n + 8\n2\n = 100\n1\n2\n + 0\n2\n + 0\n2\n = 1\n`"},"implement-queue-using-stacks":{"title":"Implement Queue using Stacks","translated_title":"用栈实现队列","question_id":"232","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/232","questions/tags/栈/简单/implement-queue-using-stacks","questions/tags/设计/简单/implement-queue-using-stacks"],"title_slug":"implement-queue-using-stacks","question":"## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n*   `void push(int x)` 将元素 x 推到队列的末尾\n*   `int pop()` 从队列的开头移除并返回元素\n*   `int peek()` 返回队列开头的元素\n*   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n \n\n**说明：**\n\n*   你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n*   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**进阶：**\n\n*   你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n**输出：**\n[null, null, null, 1, 1, false]\n\n**解释：**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= x \u003c= 9`\n*   最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n*   假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）"},"implement-stack-using-queues":{"title":"Implement Stack using Queues","translated_title":"用队列实现栈","question_id":"225","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/225","questions/tags/栈/简单/implement-stack-using-queues","questions/tags/设计/简单/implement-stack-using-queues"],"title_slug":"implement-stack-using-queues","question":"## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n使用队列实现栈的下列操作：\n\n*   push(x) -- 元素 x 入栈\n*   pop() -- 移除栈顶元素\n*   top() -- 获取栈顶元素\n*   empty() -- 返回栈是否为空\n\n**注意:**\n\n*   你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。\n*   你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n*   你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。"},"implement-trie-prefix-tree":{"title":"Implement Trie (Prefix Tree)","translated_title":"实现 Trie (前缀树)","question_id":"208","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","字典树"],"difficulty":"中等","save_dir":["questions/serial/中等/208","questions/tags/设计/中等/implement-trie-prefix-tree","questions/tags/字典树/中等/implement-trie-prefix-tree"],"title_slug":"implement-trie-prefix-tree","question":"## [实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)\n\n实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。\n\n**示例:**\n\n`Trie trie = new Trie();\n\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 true\ntrie.search(\"app\");     // 返回 false\ntrie.startsWith(\"app\"); // 返回 true\ntrie.insert(\"app\");   \ntrie.search(\"app\");     // 返回 true`\n\n**说明:**\n\n*   你可以假设所有的输入都是由小写字母 `a-z` 构成的。\n*   保证所有输入均为非空字符串。"},"insert-delete-getrandom-o1":{"title":"Insert Delete GetRandom O(1)","translated_title":"常数时间插入、删除和获取随机元素","question_id":"380","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["设计","数组","哈希表"],"difficulty":"中等","save_dir":["questions/serial/中等/380","questions/tags/设计/中等/insert-delete-getrandom-o1","questions/tags/数组/中等/insert-delete-getrandom-o1","questions/tags/哈希表/中等/insert-delete-getrandom-o1"],"title_slug":"insert-delete-getrandom-o1","question":"## [常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)\n\n设计一个支持在_平均 _时间复杂度 **O(1)** 下，执行以下操作的数据结构。\n\n1.  `insert(val)`：当元素 val 不存在时，向集合中插入该项。\n2.  `remove(val)`：元素 val 存在时，从集合中移除该项。\n3.  `getRandom`：随机返回现有集合中的一项。每个元素应该有**相同的概率**被返回。\n\n**示例 :**\n\n`\n// 初始化一个空的集合。\nRandomizedSet randomSet = new RandomizedSet();\n\n// 向集合中插入 1 。返回 true 表示 1 被成功地插入。\nrandomSet.insert(1);\n\n// 返回 false ，表示集合中不存在 2 。\nrandomSet.remove(2);\n\n// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。\nrandomSet.insert(2);\n\n// getRandom 应随机返回 1 或 2 。\nrandomSet.getRandom();\n\n// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。\nrandomSet.remove(1);\n\n// 2 已在集合中，所以返回 false 。\nrandomSet.insert(2);\n\n// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。\nrandomSet.getRandom();\n`"},"insert-into-a-binary-search-tree":{"title":"Insert into a Binary Search Tree","translated_title":"二叉搜索树中的插入操作","question_id":"784","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"中等","save_dir":["questions/serial/中等/784","questions/tags/树/中等/insert-into-a-binary-search-tree"],"title_slug":"insert-into-a-binary-search-tree","question":"## [二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n\n**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n`\n**输入：**root = [4,2,7,1,3], val = 5\n**输出：**[4,2,7,1,3,5]\n**解释：**另一个满足题目要求可以通过的树是：\n![image](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)\n`\n\n**示例 2：**\n\n`\n**输入：**root = [40,20,60,10,30,50,70], val = 25\n**输出：**[40,20,60,10,30,50,70,null,null,25]\n`\n\n**示例 3：**\n\n`\n**输入：**root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n**输出：**[4,2,7,1,3,5]\n`\n\n \n\n \n\n**提示：**\n\n*   给定的树上的节点数介于 `0` 和 `10^4` 之间\n*   每个节点都有一个唯一整数值，取值范围从 `0` 到 `10^8`\n*   `-10^8 \u003c= val \u003c= 10^8`\n*   新值和原始二叉搜索树中的任意节点值都不同"},"intersection-of-two-arrays":{"title":"Intersection of Two Arrays","translated_title":"两个数组的交集","question_id":"349","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表","双指针","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/349","questions/tags/排序/简单/intersection-of-two-arrays","questions/tags/哈希表/简单/intersection-of-two-arrays","questions/tags/双指针/简单/intersection-of-two-arrays","questions/tags/二分查找/简单/intersection-of-two-arrays"],"title_slug":"intersection-of-two-arrays","question":"## [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n \n\n**示例 1：**\n\n`**输入：**nums1 = [1,2,2,1], nums2 = [2,2]\n**输出：**[2]\n`\n\n**示例 2：**\n\n`**输入：**nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**输出：**[9,4]`\n\n \n\n**说明：**\n\n*   输出结果中的每个元素一定是唯一的。\n*   我们可以不考虑输出结果的顺序。"},"intersection-of-two-arrays-ii":{"title":"Intersection of Two Arrays II","translated_title":"两个数组的交集 II","question_id":"350","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表","双指针","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/350","questions/tags/排序/简单/intersection-of-two-arrays-ii","questions/tags/哈希表/简单/intersection-of-two-arrays-ii","questions/tags/双指针/简单/intersection-of-two-arrays-ii","questions/tags/二分查找/简单/intersection-of-two-arrays-ii"],"title_slug":"intersection-of-two-arrays-ii","question":"## [两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)\n\n给定两个数组，编写一个函数来计算它们的交集。\n\n \n\n**示例 1：**\n\n`**输入：**nums1 = [1,2,2,1], nums2 = [2,2]\n**输出：**[2,2]\n`\n\n**示例 2:**\n\n`**输入：**nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n**输出：**[4,9]`\n\n \n\n**说明：**\n\n*   输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。\n*   我们可以不考虑输出结果的顺序。\n\n**\n进阶**：\n\n\n*   如果给定的数组已经排好序呢？你将如何优化你的算法？\n*   如果 _nums1 _的大小比 _nums2 _小很多，哪种方法更优？\n*   如果 _nums2 _的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？"},"isomorphic-strings":{"title":"Isomorphic Strings","translated_title":"同构字符串","question_id":"205","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/205","questions/tags/哈希表/简单/isomorphic-strings"],"title_slug":"isomorphic-strings","question":"## [同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)\n\n给定两个字符串 _**s **_和 **_t_**，判断它们是否是同构的。\n\n如果 _**s **_中的字符可以被替换得到 **_t _**，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n**示例 1:**\n\n`**输入:** **_s_** = `\"egg\", `**_t =_ **`\"add\"`\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** **_s_** = `\"foo\", `**_t =_ **`\"bar\"`\n**输出:** false`\n\n**示例 3:**\n\n`**输入:** **_s_** = `\"paper\", `**_t =_ **`\"title\"`\n**输出:** true`\n\n**说明:**  \n\n你可以假设 _**s **_和 **_t_ **具有相同的长度。"},"jewels-and-stones":{"title":"Jewels and Stones","translated_title":"宝石与石头","question_id":"782","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/782","questions/tags/哈希表/简单/jewels-and-stones"],"title_slug":"jewels-and-stones","question":"## [宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)\n\n 给定字符串`J` 代表石头中宝石的类型，和字符串 `S`代表你拥有的石头。 `S` 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n\n`J` 中的字母不重复，`J` 和 `S`中的所有字符都是字母。字母区分大小写，因此`\"a\"`和`\"A\"`是不同类型的石头。\n\n**示例 1:**\n\n`**输入:** J = \"aA\", S = \"aAAbbbb\"\n**输出:** 3\n`\n\n**示例 2:**\n\n`**输入:** J = \"z\", S = \"ZZ\"\n**输出:** 0\n`\n\n**注意:**\n\n*   `S` 和 `J` 最多含有50个字母。\n*    `J` 中的字符不重复。"},"k-th-symbol-in-grammar":{"title":"K-th Symbol in Grammar","translated_title":"第K个语法符号","question_id":"795","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["递归"],"difficulty":"中等","save_dir":["questions/serial/中等/795","questions/tags/递归/中等/k-th-symbol-in-grammar"],"title_slug":"k-th-symbol-in-grammar","question":"## [第K个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\n在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。\n\n给定行数 `N` 和序数 `K`，返回第 `N` 行中第 `K`个字符。（`K`从1开始）\n\n**例子:**\n\n`**输入:** N = 1, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 2\n**输出:** 1\n\n**输入:** N = 4, K = 5\n**输出:** 1\n\n**解释:**\n第一行: 0\n第二行: 01\n第三行: 0110\n第四行: 01101001\n`\n\n**注意：**\n\n1.  `N` 的范围 `[1, 30]`.\n2.  `K` 的范围 `[1, 2^(N-1)]`."},"keys-and-rooms":{"title":"Keys and Rooms","translated_title":"钥匙和房间","question_id":"871","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/871","questions/tags/深度优先搜索/中等/keys-and-rooms","questions/tags/图/中等/keys-and-rooms"],"title_slug":"keys-and-rooms","question":"## [钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n`**输入:** [[1],[2],[3],[]]\n**输出:** true\n**解释:** \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n`\n\n**示例 2：**\n\n`**输入：**[[1,3],[3,0,1],[2],[0]]\n**输出：**false\n**解释：**我们不能进入 2 号房间。\n`\n\n**提示：**\n\n1.  `1 \u003c= rooms.length \u003c= 1000`\n2.  `0 \u003c= rooms[i].length \u003c= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。"},"kth-largest-element-in-a-stream":{"title":"Kth Largest Element in a Stream","translated_title":"数据流中的第 K 大元素","question_id":"789","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/789","questions/tags/堆/简单/kth-largest-element-in-a-stream","questions/tags/设计/简单/kth-largest-element-in-a-stream"],"title_slug":"kth-largest-element-in-a-stream","question":"## [数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)\n\n设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。\n\n请实现 `KthLargest` 类：\n\n*   `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。\n*   `int add(int val)` 返回当前数据流中第 `k` 大的元素。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n**输出：**\n[null, 4, 5, 5, 8, 8]\n\n**解释：**\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `0 \n4\n`\n*   `-10\n4\n \n4\n`\n*   `-10\n4\n \n4\n`\n*   最多调用 `add` 方法 `10\n4\n` 次\n*   题目数据保证，在查找第 `k` 大元素时，数组中至少有 `k` 个元素"},"longest-substring-without-repeating-characters":{"title":"Longest Substring Without Repeating Characters","translated_title":"无重复字符的最长子串","question_id":"3","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表","双指针","字符串",""],"difficulty":"中等","save_dir":["questions/serial/中等/3","questions/tags/哈希表/中等/longest-substring-without-repeating-characters","questions/tags/双指针/中等/longest-substring-without-repeating-characters","questions/tags/字符串/中等/longest-substring-without-repeating-characters","questions/tags/中等/longest-substring-without-repeating-characters"],"title_slug":"longest-substring-without-repeating-characters","question":"## [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n给定一个字符串，请你找出其中不含有重复字符的 **最长子串**的长度。\n\n \n\n**示例 1:**\n\n`\n**输入:** s = \"abcabcbb\"\n**输出:** 3 \n**解释:** 因为无重复字符的最长子串是 `\"abc\"，所以其`长度为 3。\n`\n\n**示例 2:**\n\n`\n**输入:** s = \"bbbbb\"\n**输出:** 1\n**解释:** 因为无重复字符的最长子串是 `\"b\"`，所以其长度为 1。\n`\n\n**示例 3:**\n\n`\n**输入:** s = \"pwwkew\"\n**输出:** 3\n**解释:** 因为无重复字符的最长子串是 `\"wke\"`，所以其长度为 3。\n     请注意，你的答案必须是 **子串** 的长度，`\"pwke\"` 是一个_子序列，_不是子串。\n`\n\n**示例 4:**\n\n`\n**输入:** s = \"\"\n**输出:** 0\n`\n\n \n\n**提示：**\n\n*   `0 \n4\n`\n*   `s` 由英文字母、数字、符号和空格组成"},"lowest-common-ancestor-of-a-binary-search-tree":{"title":"Lowest Common Ancestor of a Binary Search Tree","translated_title":"二叉搜索树的最近公共祖先","question_id":"235","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/235","questions/tags/树/简单/lowest-common-ancestor-of-a-binary-search-tree"],"title_slug":"lowest-common-ancestor-of-a-binary-search-tree","question":"## [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)\n\n \n\n**示例 1:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**输出:** 6 \n**解释:** 节点 `2 `和节点 `8 `的最近公共祖先是 `6。`\n`\n\n**示例 2:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**输出:** 2\n**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。`\n\n \n\n**说明:**\n\n*   所有节点的值都是唯一的。\n*   p、q 为不同节点且均存在于给定的二叉搜索树中。"},"maximum-repeating-substring":{"title":"Maximum Repeating Substring","translated_title":"最大重复子字符串","question_id":"1764","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/1764","questions/tags/字符串/简单/maximum-repeating-substring"],"title_slug":"maximum-repeating-substring","question":"## [最大重复子字符串](https://leetcode-cn.com/problems/maximum-repeating-substring/)\n\n给你一个字符串 `sequence` ，如果字符串 `word` 连续重复 `k` 次形成的字符串是 `sequence` 的一个子字符串，那么单词 `word` 的 **重复值为 `k`** **** 。单词 `word` 的 **最****大重复值** 是单词 `word` 在 `sequence` 中最大的重复值。如果 `word` 不是 `sequence` 的子串，那么重复值 `k` 为 `0` 。\n\n给你一个字符串 `sequence` 和 `word` ，请你返回 **最大重复值 `k`** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ab\"\n**输出：**2\n**解释：**\"abab\" 是 \"**abab**c\" 的子字符串。\n`\n\n**示例 2：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ba\"\n**输出：**1\n**解释：**\"ba\" 是 \"a**ba**bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n`\n\n**示例 3：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ac\"\n**输出：**0\n**解释：**\"ac\" 不是 \"ababc\" 的子字符串。\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= sequence.length \u003c= 100`\n*   `1 \u003c= word.length \u003c= 100`\n*   `sequence` 和 `word` 都只包含小写英文字母。"},"merge-two-sorted-lists":{"title":"Merge Two Sorted Lists","translated_title":"合并两个有序链表","question_id":"21","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"简单","save_dir":["questions/serial/简单/21","questions/tags/链表/简单/merge-two-sorted-lists"],"title_slug":"merge-two-sorted-lists","question":"## [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n**示例：**\n\n`**输入：**1-\u003e2-\u003e4, 1-\u003e3-\u003e4\n**输出：**1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4\n`"},"minimum-index-sum-of-two-lists":{"title":"Minimum Index Sum of Two Lists","translated_title":"两个列表的最小索引总和","question_id":"599","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/599","questions/tags/哈希表/简单/minimum-index-sum-of-two-lists"],"title_slug":"minimum-index-sum-of-two-lists","question":"## [两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)\n\n假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。\n\n你需要帮助他们用**最少的索引和**找出他们**共同喜爱的餐厅**。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。\n\n**示例 1:**\n\n`**输入:**\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n**输出:** [\"Shogun\"]\n**解释:** 他们唯一共同喜爱的餐厅是“Shogun”。\n`\n\n**示例 2:**\n\n`**输入:**\n[\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n[\"KFC\", \"Shogun\", \"Burger King\"]\n**输出:** [\"Shogun\"]\n**解释:** 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n`\n\n**提示:**\n\n1.  两个列表的长度范围都在 [1, 1000]内。\n2.  两个列表中的字符串的长度将在[1，30]的范围内。\n3.  下标从0开始，到列表的长度减1。\n4.  两个列表都没有重复的元素。"},"n-ary-tree-postorder-traversal":{"title":"N-ary Tree Postorder Traversal","translated_title":"N叉树的后序遍历","question_id":"776","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/776","questions/tags/树/简单/n-ary-tree-postorder-traversal"],"title_slug":"n-ary-tree-postorder-traversal","question":"## [N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的_后序遍历_。\n\n例如，给定一个 `3叉树` :\n\n \n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png)\n\n \n\n返回其后序遍历: `[5,6,3,2,4,1]`.\n\n \n\n**说明:** 递归法很简单，你可以使用迭代法完成此题吗?"},"n-ary-tree-preorder-traversal":{"title":"N-ary Tree Preorder Traversal","translated_title":"N叉树的前序遍历","question_id":"775","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/775","questions/tags/树/简单/n-ary-tree-preorder-traversal"],"title_slug":"n-ary-tree-preorder-traversal","question":"## [N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n\n给定一个 N 叉树，返回其节点值的_前序遍历_。\n\n例如，给定一个 `3叉树` :\n\n \n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png)\n\n \n\n返回其前序遍历: `[1,3,5,6,2,4]`。\n\n \n\n**说明: **递归法很简单，你可以使用迭代法完成此题吗?"},"pascals-triangle":{"title":"Pascal's Triangle","translated_title":"杨辉三角","question_id":"118","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/118","questions/tags/数组/简单/pascals-triangle"],"title_slug":"pascals-triangle","question":"## [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\n给定一个非负整数 _numRows，_生成杨辉三角的前 _numRows _行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 5\n**输出:**\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]`"},"pascals-triangle-ii":{"title":"Pascal's Triangle II","translated_title":"杨辉三角 II","question_id":"119","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/119","questions/tags/数组/简单/pascals-triangle-ii"],"title_slug":"pascals-triangle-ii","question":"## [杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n给定一个非负索引 _k_，其中 _k_ ≤ 33，返回杨辉三角的第 _k_ 行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 3\n**输出:** [1,3,3,1]\n`\n\n**进阶：**\n\n你可以优化你的算法到 _O_(_k_) 空间复杂度吗？"},"powx-n":{"title":"Pow(x, n)","translated_title":"Pow(x, n)","question_id":"50","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/50","questions/tags/数学/中等/powx-n","questions/tags/二分查找/中等/powx-n"],"title_slug":"powx-n","question":"## [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。\n\n**示例 1:**\n\n`**输入:** 2.00000, 10\n**输出:** 1024.00000\n`\n\n**示例 2:**\n\n`**输入:** 2.10000, 3\n**输出:** 9.26100\n`\n\n**示例 3:**\n\n`**输入:** 2.00000, -2\n**输出:** 0.25000\n**解释:** 2\n-2\n = 1/2\n2\n = 1/4 = 0.25`\n\n**说明:**\n\n*   -100.0 \u003c _x_ \u003c 100.0\n*   _n_ 是 32 位有符号整数，其数值范围是 [−2\n31\n, 2\n31 \n− 1] 。"},"reverse-string":{"title":"Reverse String","translated_title":"反转字符串","question_id":"344","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/344","questions/tags/双指针/简单/reverse-string","questions/tags/字符串/简单/reverse-string"],"title_slug":"reverse-string","question":"## [反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。\n\n \n\n**示例 1：**\n\n`**输入：**[\"h\",\"e\",\"l\",\"l\",\"o\"]\n**输出：**[\"o\",\"l\",\"l\",\"e\",\"h\"]\n`\n\n**示例 2：**\n\n`**输入：**[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n**输出：**[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]`"},"richest-customer-wealth":{"title":"Richest Customer Wealth","translated_title":"最富有客户的资产总量","question_id":"1791","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/1791","questions/tags/数组/简单/richest-customer-wealth"],"title_slug":"richest-customer-wealth","question":"## [最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)\n\n给你一个 `m x n` 的整数网格 `accounts` ，其中 `accounts[i][j]` 是第 `i​​​​​\n​​​​​​\n​` 位客户在第 `j` 家银行托管的资产数量。返回最富有客户所拥有的 **资产总量** 。\n\n客户的 **资产总量** 就是他们在各家银行托管的资产数量之和。最富有客户就是 **资产总量** 最大的客户。\n\n \n\n**示例 1：**\n\n`**输入：**accounts = [[1,2,3],[3,2,1]]\n**输出：**6\n**解释：**\n`第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n`两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n`\n\n**示例 2：**\n\n`**输入：**accounts = [[1,5],[7,3],[3,5]]\n**输出：**10\n**解释：**\n`第 1 位客户的资产总量` = 6\n`第 2 位客户的资产总量` = 10 \n`第 3 位客户的资产总量` = 8\n第 2 位客户是最富有的，资产总量是 10`\n\n**示例 3：**\n\n`**输入：**accounts = [[2,8,7],[7,1,3],[1,9,5]]\n**输出：**17\n`\n\n \n\n**提示：**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 \u003c= m, n \u003c= 50`\n*   `1 \u003c= accounts[i][j] \u003c= 100`"},"search-in-a-binary-search-tree":{"title":"Search in a Binary Search Tree","translated_title":"二叉搜索树中的搜索","question_id":"783","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/783","questions/tags/树/简单/search-in-a-binary-search-tree"],"title_slug":"search-in-a-binary-search-tree","question":"## [二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n例如，\n\n`\n给定二叉搜索树:\n\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\n和值: 2\n`\n\n你应该返回如下子树:\n\n`\n      2     \n     / \\   \n    1   3\n`\n\n在上述示例中，如果要找的值是 `5`，但因为没有节点值为 `5`，我们应该返回 `NULL`。"},"search-in-rotated-sorted-array":{"title":"Search in Rotated Sorted Array","translated_title":"搜索旋转排序数组","question_id":"33","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/33","questions/tags/数组/中等/search-in-rotated-sorted-array","questions/tags/二分查找/中等/search-in-rotated-sorted-array"],"title_slug":"search-in-rotated-sorted-array","question":"## [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n给你一个整数数组 `nums` ，和一个整数 `target` 。\n\n该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` ）。\n\n请你在数组中搜索 `target` ，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 0\n**输出：**4\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 3\n**输出：**-1`\n\n**示例 3：**\n\n`\n**输入：**nums = [1], target = 0\n**输出：**-1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-10^4 \u003c= nums[i] \u003c= 10^4`\n*   `nums` 中的每个值都 **独一无二**\n*   `nums` 肯定会在某个点上旋转\n*   `-10^4 \u003c= target \u003c= 10^4`"},"search-insert-position":{"title":"Search Insert Position","translated_title":"搜索插入位置","question_id":"35","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/35","questions/tags/数组/简单/search-insert-position","questions/tags/二分查找/简单/search-insert-position"],"title_slug":"search-insert-position","question":"## [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n`**输入:** [1,3,5,6], 5\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** [1,3,5,6], 2\n**输出:** 1\n`\n\n**示例 3:**\n\n`**输入:** [1,3,5,6], 7\n**输出:** 4\n`\n\n**示例 4:**\n\n`**输入:** [1,3,5,6], 0\n**输出:** 0\n`"},"single-number":{"title":"Single Number","translated_title":"只出现一次的数字","question_id":"136","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["位运算","哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/136","questions/tags/位运算/简单/single-number","questions/tags/哈希表/简单/single-number"],"title_slug":"single-number","question":"## [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n**说明：**\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**示例 1:**\n\n`**输入:** [2,2,1]\n**输出:** 1\n`\n\n**示例 2:**\n\n`**输入:** [4,1,2,1,2]\n**输出:** 4`"},"sort-characters-by-frequency":{"title":"Sort Characters By Frequency","translated_title":"根据字符出现频率排序","question_id":"451","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","哈希表"],"difficulty":"中等","save_dir":["questions/serial/中等/451","questions/tags/堆/中等/sort-characters-by-frequency","questions/tags/哈希表/中等/sort-characters-by-frequency"],"title_slug":"sort-characters-by-frequency","question":"## [根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n**示例 1:**\n\n`\n**输入:**\n\"tree\"\n\n**输出:**\n\"eert\"\n\n**解释:** 'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n`\n\n**示例 2:**\n\n`\n**输入:**\n\"cccaaa\"\n\n**输出:**\n\"cccaaa\"\n\n**解释:** 'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n`\n\n**示例 3:**\n\n`\n**输入:**\n\"Aabb\"\n\n**输出:**\n\"bbAa\"\n\n**解释:** 此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n`"},"split-array-into-consecutive-subsequences":{"title":"Split Array into Consecutive Subsequences","translated_title":"分割数组为连续子序列","question_id":"659","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","贪心算法"],"difficulty":"中等","save_dir":["questions/serial/中等/659","questions/tags/堆/中等/split-array-into-consecutive-subsequences","questions/tags/贪心算法/中等/split-array-into-consecutive-subsequences"],"title_slug":"split-array-into-consecutive-subsequences","question":"## [分割数组为连续子序列](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)\n\n给你一个按升序排序的整数数组 `num`（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。\n\n如果可以完成上述分割，则返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n`**输入:** [1,2,3,3,4,5]\n**输出:** True\n**解释:**\n你可以分割出这样两个连续子序列 : \n1, 2, 3\n3, 4, 5\n`\n\n \n\n**示例 2：**\n\n`**输入:** [1,2,3,3,4,4,5,5]\n**输出:** True\n**解释:**\n你可以分割出这样两个连续子序列 : \n1, 2, 3, 4, 5\n3, 4, 5\n`\n\n \n\n**示例 3：**\n\n`**输入:** [1,2,3,4,4,5]\n**输出:** False\n`\n\n \n\n**提示：**\n\n1.  输入的数组长度范围为 [1, 10000]\n\n "},"sqrtx":{"title":"Sqrt(x)","translated_title":"x 的平方根","question_id":"69","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/69","questions/tags/数学/简单/sqrtx","questions/tags/二分查找/简单/sqrtx"],"title_slug":"sqrtx","question":"## [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n实现 `int sqrt(int x)` 函数。\n\n计算并返回 _x_ 的平方根，其中 _x_ 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n**示例 1:**\n\n`**输入:** 4\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** 8\n**输出:** 2\n**说明:** 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n`"},"swap-nodes-in-pairs":{"title":"Swap Nodes in Pairs","translated_title":"两两交换链表中的节点","question_id":"24","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"中等","save_dir":["questions/serial/中等/24","questions/tags/链表/中等/swap-nodes-in-pairs"],"title_slug":"swap-nodes-in-pairs","question":"## [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n`\n**输入：**head = [1,2,3,4]\n**输出：**[2,1,4,3]\n`\n\n**示例 2：**\n\n`\n**输入：**head = []\n**输出：**[]\n`\n\n**示例 3：**\n\n`\n**输入：**head = [1]\n**输出：**[1]\n`\n\n \n\n**提示：**\n\n*   链表中节点的数目在范围 `[0, 100]` 内\n*   `0 \u003c= Node.val \u003c= 100`"},"symmetric-tree":{"title":"Symmetric Tree","translated_title":"对称二叉树","question_id":"101","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索","广度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/101","questions/tags/树/简单/symmetric-tree","questions/tags/深度优先搜索/简单/symmetric-tree","questions/tags/广度优先搜索/简单/symmetric-tree"],"title_slug":"symmetric-tree","question":"## [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n`    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n`\n\n \n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n`    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n`\n\n \n\n**进阶：**\n\n你可以运用递归和迭代两种方法解决这个问题吗？"},"target-sum":{"title":"Target Sum","translated_title":"目标和","question_id":"494","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/494","questions/tags/深度优先搜索/中等/target-sum","questions/tags/动态规划/中等/target-sum"],"title_slug":"target-sum","question":"## [目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n \n\n**示例：**\n\n`**输入：**nums: [1, 1, 1, 1, 1], S: 3\n**输出：**5\n**解释：**\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n`\n\n \n\n**提示：**\n\n*   数组非空，且长度不会超过 20 。\n*   初始的数组的和不会超过 1000 。\n*   保证返回的最终结果能被 32 位整数存下。"},"task-scheduler":{"title":"Task Scheduler","translated_title":"任务调度器","question_id":"621","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["贪心算法","队列","数组"],"difficulty":"中等","save_dir":["questions/serial/中等/621","questions/tags/贪心算法/中等/task-scheduler","questions/tags/队列/中等/task-scheduler","questions/tags/数组/中等/task-scheduler"],"title_slug":"task-scheduler","question":"## [任务调度器](https://leetcode-cn.com/problems/task-scheduler/)\n\n给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。\n\n然而，两个 **相同种类** 的任务之间必须有长度为整数 **** `n` **** 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。\n\n你需要计算完成所有任务所需要的 **最短时间** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n**输出：**8\n**解释：**A -\u003e B -\u003e (待命) -\u003e A -\u003e B -\u003e (待命) -\u003e A -\u003e B\n     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 `\n\n**示例 2：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n**输出：**6\n**解释：**在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n诸如此类\n`\n\n**示例 3：**\n\n`\n**输入：**tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n**输出：**16\n**解释：**一种可能的解决方案是：\n     A -\u003e B -\u003e C -\u003e A -\u003e D -\u003e E -\u003e A -\u003e F -\u003e G -\u003e A -\u003e (待命) -\u003e (待命) -\u003e A -\u003e (待命) -\u003e (待命) -\u003e A\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `tasks[i]` 是大写英文字母\n*   `n` 的取值范围为 `[0, 100]`"},"top-k-frequent-elements":{"title":"Top K Frequent Elements","translated_title":"前 K 个高频元素","question_id":"347","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","哈希表"],"difficulty":"中等","save_dir":["questions/serial/中等/347","questions/tags/堆/中等/top-k-frequent-elements","questions/tags/哈希表/中等/top-k-frequent-elements"],"title_slug":"top-k-frequent-elements","question":"## [前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\n给定一个非空的整数数组，返回其中出现频率前 **_k _**高的元素。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,1,1,2,2,3], k = 2\n**输出:** [1,2]\n`\n\n**示例 2:**\n\n`**输入:** nums = [1], k = 1\n**输出:** [1]`\n\n \n\n**提示：**\n\n*   你可以假设给定的 _k _总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n*   你的算法的时间复杂度**必须**优于 O(_n_ log _n_) , _n _是数组的大小。\n*   题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。\n*   你可以按任意顺序返回答案。"},"unique-binary-search-trees-ii":{"title":"Unique Binary Search Trees II","translated_title":"不同的二叉搜索树 II","question_id":"95","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/95","questions/tags/树/中等/unique-binary-search-trees-ii","questions/tags/动态规划/中等/unique-binary-search-trees-ii"],"title_slug":"unique-binary-search-trees-ii","question":"## [不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 _n_，生成所有由 1 ... _n_ 为节点所组成的 **二叉搜索树** 。\n\n \n\n**示例：**\n\n`**输入：**3\n**输出：**\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n**解释：**\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 8`"},"valid-anagram":{"title":"Valid Anagram","translated_title":"有效的字母异位词","question_id":"242","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序","哈希表"],"difficulty":"简单","save_dir":["questions/serial/简单/242","questions/tags/排序/简单/valid-anagram","questions/tags/哈希表/简单/valid-anagram"],"title_slug":"valid-anagram","question":"## [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)\n\n给定两个字符串 _s_ 和 _t_ ，编写一个函数来判断 _t_ 是否是 _s_ 的字母异位词。\n\n**示例 1:**\n\n`**输入:** _s_ = \"anagram\", _t_ = \"nagaram\"\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:** _s_ = \"rat\", _t_ = \"car\"\n**输出:** false`\n\n**说明:**  \n\n你可以假设字符串只包含小写字母。\n\n**进阶:**  \n\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？"},"valid-perfect-square":{"title":"Valid Perfect Square","translated_title":"有效的完全平方数","question_id":"367","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/367","questions/tags/数学/简单/valid-perfect-square","questions/tags/二分查找/简单/valid-perfect-square"],"title_slug":"valid-perfect-square","question":"## [有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)\n\n给定一个正整数 _num_，编写一个函数，如果 _num_ 是一个完全平方数，则返回 True，否则返回 False。\n\n**说明：**不要使用任何内置的库函数，如  `sqrt`。\n\n**示例 1：**\n\n`**输入：**16\n**输出：**True`\n\n**示例 2：**\n\n`**输入：**14\n**输出：**False\n`"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","translated_title":"验证二叉搜索树","question_id":"98","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/98","questions/tags/树/中等/validate-binary-search-tree","questions/tags/深度优先搜索/中等/validate-binary-search-tree"],"title_slug":"validate-binary-search-tree","question":"## [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n*   节点的左子树只包含**小于**当前节点的数。\n*   节点的右子树只包含**大于**当前节点的数。\n*   所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n`**输入:**\n    2\n   / \\\n  1   3\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:**     5\n   / \\\n  1   4\n     / \\\n    3   6\n**输出:** false\n**解释:** 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n`"}}