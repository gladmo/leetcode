{"":{"title":"","translated_title":"","question_id":"","language":null,"tags":null,"difficulty":"","save_dir":["questions/serial"],"title_slug":"","question":"## [](https://leetcode-cn.com/problems//)\n\n"},"01-matrix":{"title":"01 Matrix","translated_title":"01 矩阵","question_id":"542","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","广度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/542","questions/tags/深度优先搜索/中等/01-matrix","questions/tags/广度优先搜索/中等/01-matrix"],"title_slug":"01-matrix","question":"## [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n \n\n**示例 1：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n`\n\n**示例 2：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n`\n\n \n\n**提示：**\n\n*   给定矩阵的元素个数不超过 10000。\n*   给定矩阵中至少有一个元素是 0。\n*   矩阵中的元素只在四个方向上相邻: 上、下、左、右。"},"balanced-binary-tree":{"title":"Balanced Binary Tree","translated_title":"平衡二叉树","question_id":"110","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/110","questions/tags/树/简单/balanced-binary-tree","questions/tags/深度优先搜索/简单/balanced-binary-tree"],"title_slug":"balanced-binary-tree","question":"## [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)\n\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n\u003e 一个二叉树_每个节点_的左右两个子树的高度差的绝对值不超过 1 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n`\n**输入：**root = [3,9,20,null,null,15,7]\n**输出：**true\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n`\n**输入：**root = [1,2,2,3,3,null,null,4,4]\n**输出：**false\n`\n\n**示例 3：**\n\n`\n**输入：**root = []\n**输出：**true\n`\n\n \n\n**提示：**\n\n*   树中的节点数在范围 `[0, 5000]` 内\n*   `-10\n4\n \n4\n`"},"binary-search":{"title":"Binary Search","translated_title":"二分查找","question_id":"792","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/792","questions/tags/二分查找/简单/binary-search"],"title_slug":"binary-search","question":"## [二分查找](https://leetcode-cn.com/problems/binary-search/)\n\n给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n**示例 1:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 9\n**输出:** 4\n**解释:** 9 出现在 `nums` 中并且下标为 4\n`\n\n**示例 2:**\n\n`**输入:** `nums` = [-1,0,3,5,9,12], `target` = 2\n**输出:** -1\n**解释:** 2 不存在 `nums` 中因此返回 -1\n`\n\n \n\n**提示：**\n\n1.  你可以假设 `nums` 中的所有元素是不重复的。\n2.  `n` 将在 `[1, 10000]`之间。\n3.  `nums` 的每个元素都将在 `[-9999, 9999]`之间。"},"binary-search-tree-iterator":{"title":"Binary Search Tree Iterator","translated_title":"二叉搜索树迭代器","question_id":"173","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","树","设计"],"difficulty":"中等","save_dir":["questions/serial/中等/173","questions/tags/栈/中等/binary-search-tree-iterator","questions/tags/树/中等/binary-search-tree-iterator","questions/tags/设计/中等/binary-search-tree-iterator"],"title_slug":"binary-search-tree-iterator","question":"## [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n \n\n**示例：**\n\n**![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/25/bst-tree.png)**\n\n`BSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false`\n\n \n\n**提示：**\n\n*   `next()` 和 `hasNext()` 操作的时间复杂度是 O(1)，并使用 O(_h_) 内存，其中 _h _是树的高度。\n*   你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 中至少存在一个下一个最小的数。"},"climbing-stairs":{"title":"Climbing Stairs","translated_title":"爬楼梯","question_id":"70","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["动态规划"],"difficulty":"简单","save_dir":["questions/serial/简单/70","questions/tags/动态规划/简单/climbing-stairs"],"title_slug":"climbing-stairs","question":"## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 _n_ 是一个正整数。\n\n**示例 1：**\n\n`**输入：** 2\n**输出：** 2\n**解释：** 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶`\n\n**示例 2：**\n\n`**输入：** 3\n**输出：** 3\n**解释：** 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n`"},"clone-graph":{"title":"Clone Graph","translated_title":"克隆图","question_id":"133","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["深度优先搜索","广度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/133","questions/tags/深度优先搜索/中等/clone-graph","questions/tags/广度优先搜索/中等/clone-graph","questions/tags/图/中等/clone-graph"],"title_slug":"clone-graph","question":"## [克隆图](https://leetcode-cn.com/problems/clone-graph/)\n\n给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin) **图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。\n\n图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。\n\n`class Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n}`\n\n \n\n**测试用例格式：**\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。\n\n**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝 **作为对克隆图的引用返回。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)\n\n`**输入：**adjList = [[2,4],[1,3],[2,4],[1,3]]\n**输出：**[[2,4],[1,3],[2,4],[1,3]]\n**解释：** 图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)\n\n`**输入：**adjList = [[]]\n**输出：**[[]]\n**解释：**输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n`\n\n**示例 3：**\n\n`**输入：**adjList = []\n**输出：**[]\n**解释：**这个图是空的，它不含任何节点。\n`\n\n**示例 4：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)\n\n`**输入：**adjList = [[2],[1]]\n**输出：**[[2],[1]]`\n\n \n\n**提示：**\n\n1.  节点数不超过 100 。\n2.  每个节点值 `Node.val` 都是唯一的，`1 \u003c= Node.val \u003c= 100`。\n3.  无向图是一个[简单图](https://baike.baidu.com/item/简单图/1680528?fr=aladdin)，这意味着图中没有重复的边，也没有自环。\n4.  由于图是无向的，如果节点 _p_ 是节点 _q_ 的邻居，那么节点 _q_ 也必须是节点 _p_ 的邻居。\n5.  图是连通图，你可以从给定节点访问到所有节点。"},"contains-duplicate-iii":{"title":"Contains Duplicate III","translated_title":"存在重复元素 III","question_id":"220","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["排序",""],"difficulty":"中等","save_dir":["questions/serial/中等/220","questions/tags/排序/中等/contains-duplicate-iii","questions/tags/中等/contains-duplicate-iii"],"title_slug":"contains-duplicate-iii","question":"## [存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)\n\n在整数数组 `nums` 中，是否存在两个下标 **_i_** 和 **_j_**，使得 **nums [i]** 和 **nums [j]** 的差的绝对值小于等于 _**t**_ ，且满足 **_i_** 和 **_j_** 的差的绝对值也小于等于 _**ķ**_ 。\n\n如果存在则返回 `true`，不存在返回 `false`。\n\n \n\n**示例 1:**\n\n`**输入:** nums = [1,2,3,1], k __ = 3, t = 0\n**输出:** true`\n\n**示例 2:**\n\n`**输入:** nums = [1,0,1,1], k __ = __ 1, t = 2\n**输出:** true`\n\n**示例 3:**\n\n`**输入:** nums = [1,5,9,1,5,9], k = 2, t = 3\n**输出:** false`"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","translated_title":"完全二叉树的节点个数","question_id":"222","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/222","questions/tags/树/中等/count-complete-tree-nodes","questions/tags/二分查找/中等/count-complete-tree-nodes"],"title_slug":"count-complete-tree-nodes","question":"## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2\nh\n 个节点。\n\n**示例:**\n\n`**输入:** \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n**输出:** 6`"},"decode-string":{"title":"Decode String","translated_title":"字符串解码","question_id":"394","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/394","questions/tags/栈/中等/decode-string","questions/tags/深度优先搜索/中等/decode-string"],"title_slug":"decode-string","question":"## [字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 _encoded_string_ 正好重复 _k_ 次。注意 _k_ 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 _k_ ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n`**输入：**s = \"3[a]2[bc]\"\n**输出：**\"aaabcbc\"\n`\n\n**示例 2：**\n\n`**输入：**s = \"3[a2[c]]\"\n**输出：**\"accaccacc\"\n`\n\n**示例 3：**\n\n`**输入：**s = \"2[abc]3[cd]ef\"\n**输出：**\"abcabccdcdcdef\"\n`\n\n**示例 4：**\n\n`**输入：**s = \"abc3[cd]xyz\"\n**输出：**\"abccdcdcdxyz\"\n`"},"delete-node-in-a-bst":{"title":"Delete Node in a BST","translated_title":"删除二叉搜索树中的节点","question_id":"450","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"中等","save_dir":["questions/serial/中等/450","questions/tags/树/中等/delete-node-in-a-bst"],"title_slug":"delete-node-in-a-bst","question":"## [删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)\n\n给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key **对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n1.  首先找到需要删除的节点；\n2.  如果找到了，删除它。\n\n**说明：** 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n**示例:**\n\n`\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n`"},"fibonacci-number":{"title":"Fibonacci Number","translated_title":"斐波那契数","question_id":"1013","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/1013","questions/tags/数组/简单/fibonacci-number"],"title_slug":"fibonacci-number","question":"## [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)\n\n**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n`F(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1.\n`\n\n给定 `N`，计算 `F(N)`。\n\n \n\n**示例 1：**\n\n`**输入：**2\n**输出：**1\n**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1.\n`\n\n**示例 2：**\n\n`**输入：**3\n**输出：**2\n**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2.\n`\n\n**示例 3：**\n\n`**输入：**4\n**输出：**3\n**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3.\n`\n\n \n\n**提示：**\n\n*   0 ≤ `N` ≤ 30"},"find-first-and-last-position-of-element-in-sorted-array":{"title":"Find First and Last Position of Element in Sorted Array","translated_title":"在排序数组中查找元素的第一个和最后一个位置","question_id":"34","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/34","questions/tags/数组/中等/find-first-and-last-position-of-element-in-sorted-array","questions/tags/二分查找/中等/find-first-and-last-position-of-element-in-sorted-array"],"title_slug":"find-first-and-last-position-of-element-in-sorted-array","question":"## [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n给定一个按照升序排列的整数数组 `nums`，和一个目标值 `target`。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n\n**进阶：**\n\n*   你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 8\n**输出：**[3,4]`\n\n**示例 2：**\n\n`\n**输入：**nums = [`5,7,7,8,8,10]`, target = 6\n**输出：**[-1,-1]`\n\n**示例 3：**\n\n`\n**输入：**nums = [], target = 0\n**输出：**[-1,-1]`\n\n \n\n**提示：**\n\n*   `0 \u003c= nums.length \u003c= 105`\n*   `-109 \u003c= nums[i] \u003c= 109`\n*   `nums` 是一个非递减数组\n*   `-109 \u003c= target \u003c= 109`"},"find-k-closest-elements":{"title":"Find K Closest Elements","translated_title":"找到 K 个最接近的元素","question_id":"658","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/658","questions/tags/二分查找/中等/find-k-closest-elements"],"title_slug":"find-k-closest-elements","question":"## [找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)\n\n给定一个排序好的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。\n\n整数 `a` 比整数 `b` 更接近 `x` 需要满足：\n\n*   `|a - x| \n4\n`\n*   数组里的每个元素与 `x` 的绝对值不超过 `10\n4\n`"},"find-minimum-in-rotated-sorted-array":{"title":"Find Minimum in Rotated Sorted Array","translated_title":"寻找旋转排序数组中的最小值","question_id":"153","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/153","questions/tags/数组/中等/find-minimum-in-rotated-sorted-array","questions/tags/二分查找/中等/find-minimum-in-rotated-sorted-array"],"title_slug":"find-minimum-in-rotated-sorted-array","question":"## [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n\n假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 `[0,1,2,4,5,6,7]`  **** 可能变为 `[4,5,6,7,0,1,2]` 。\n\n请找出其中最小的元素。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [3,4,5,1,2]\n**输出：**1\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [4,5,6,7,0,1,2]\n**输出：**0\n`\n\n**示例 3：**\n\n`\n**输入：**nums = [1]\n**输出：**1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-5000 \u003c= nums[i] \u003c= 5000`\n*   `nums` 中的所有整数都是 **唯一** 的\n*   `nums` 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转"},"find-peak-element":{"title":"Find Peak Element","translated_title":"寻找峰值","question_id":"162","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/162","questions/tags/数组/中等/find-peak-element","questions/tags/二分查找/中等/find-peak-element"],"title_slug":"find-peak-element","question":"## [寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n\n峰值元素是指其值大于左右相邻值的元素。\n\n给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。\n\n数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。\n\n你可以假设 `nums[-1] = nums[n] = -∞`。\n\n**示例 1:**\n\n`**输入:** **nums** = `[1,2,3,1]`\n**输出:** 2\n**解释:** 3 是峰值元素，你的函数应该返回其索引 2。`\n\n**示例 2:**\n\n`**输入:** **nums** = `[`1,2,1,3,5,6,4]\n**输出:** 1 或 5 \n**解释:** 你的函数可以返回索引 1，其峰值元素为 2；\n     或者返回索引 5， 其峰值元素为 6。\n`\n\n**说明:**\n\n你的解法应该是 _O_(_logN_)_ _时间复杂度的。"},"find-pivot-index":{"title":"Find Pivot Index","translated_title":"寻找数组的中心索引","question_id":"724","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/724","questions/tags/数组/简单/find-pivot-index"],"title_slug":"find-pivot-index","question":"## [寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)\n\n给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。\n\n我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n \n\n**示例 1：**\n\n`**输入：**\nnums = [1, 7, 3, 6, 5, 6]\n**输出：**3\n**解释：**\n索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。\n同时, 3 也是第一个符合要求的中心索引。\n`\n\n**示例 2：**\n\n`**输入：**\nnums = [1, 2, 3]\n**输出：**-1\n**解释：**\n数组中不存在满足此条件的中心索引。`\n\n \n\n**说明：**\n\n*   `nums` 的长度范围为 `[0, 10000]`。\n*   任何一个 `nums[i]` 将会是一个范围在 `[-1000, 1000]`的整数。"},"first-bad-version":{"title":"First Bad Version","translated_title":"第一个错误的版本","question_id":"278","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/278","questions/tags/二分查找/简单/first-bad-version"],"title_slug":"first-bad-version","question":"## [第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)\n\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n**示例:**\n\n`给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n`调用 isBadVersion(3) -\u003e false\n调用 isBadVersion(5) -\u003e true\n调用 isBadVersion(4) -\u003e true\n\n所以，4 是第一个错误的版本。 ``"},"flood-fill":{"title":"Flood Fill","translated_title":"图像渲染","question_id":"733","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/733","questions/tags/深度优先搜索/简单/flood-fill"],"title_slug":"flood-fill","question":"## [图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n`\n**输入:** \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n**输出:** [[2,2,2],[2,2,0],[2,0,1]]\n**解析:** \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n`\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 \u003c= sr \u003c image.length` 和 `0 \u003c= sc \u003c image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。"},"guess-number-higher-or-lower":{"title":"Guess Number Higher or Lower","translated_title":"猜数字大小","question_id":"374","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php"],"tags":["二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/374","questions/tags/二分查找/简单/guess-number-higher-or-lower"],"title_slug":"guess-number-higher-or-lower","question":"## [猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)\n\n猜数字游戏的规则如下：\n\n*   每轮游戏，我都会从 **1** 到 _**n**_ 随机选择一个数字。 请你猜选出的是哪个数字。\n*   如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 `int guess(int num)` 来获取猜测结果，返回值一共有 3 种可能的情况（`-1`，`1` 或 `0`）：\n\n*   -1：我选出的数字比你猜的数字小 `pick \n num`\n*   0：我选出的数字和你猜的数字一样。恭喜！你猜对了！`pick == num`\n\n \n\n**示例 1：**\n\n`\n**输入：**n = 10, pick = 6\n**输出：**6\n`\n\n**示例 2：**\n\n`\n**输入：**n = 1, pick = 1\n**输出：**1\n`\n\n**示例 3：**\n\n`\n**输入：**n = 2, pick = 1\n**输出：**1\n`\n\n**示例 4：**\n\n`\n**输入：**n = 2, pick = 2\n**输出：**2\n`\n\n \n\n**提示：**\n\n*   `1 \n31\n - 1`\n*   `1 \u003c= pick \u003c= n`"},"implement-queue-using-stacks":{"title":"Implement Queue using Stacks","translated_title":"用栈实现队列","question_id":"232","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/232","questions/tags/栈/简单/implement-queue-using-stacks","questions/tags/设计/简单/implement-queue-using-stacks"],"title_slug":"implement-queue-using-stacks","question":"## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n*   `void push(int x)` 将元素 x 推到队列的末尾\n*   `int pop()` 从队列的开头移除并返回元素\n*   `int peek()` 返回队列开头的元素\n*   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n \n\n**说明：**\n\n*   你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n*   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**进阶：**\n\n*   你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n**输出：**\n[null, null, null, 1, 1, false]\n\n**解释：**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= x \u003c= 9`\n*   最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n*   假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）"},"implement-stack-using-queues":{"title":"Implement Stack using Queues","translated_title":"用队列实现栈","question_id":"225","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/225","questions/tags/栈/简单/implement-stack-using-queues","questions/tags/设计/简单/implement-stack-using-queues"],"title_slug":"implement-stack-using-queues","question":"## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n使用队列实现栈的下列操作：\n\n*   push(x) -- 元素 x 入栈\n*   pop() -- 移除栈顶元素\n*   top() -- 获取栈顶元素\n*   empty() -- 返回栈是否为空\n\n**注意:**\n\n*   你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。\n*   你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n*   你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。"},"insert-into-a-binary-search-tree":{"title":"Insert into a Binary Search Tree","translated_title":"二叉搜索树中的插入操作","question_id":"784","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"中等","save_dir":["questions/serial/中等/784","questions/tags/树/中等/insert-into-a-binary-search-tree"],"title_slug":"insert-into-a-binary-search-tree","question":"## [二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n\n**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n`\n**输入：**root = [4,2,7,1,3], val = 5\n**输出：**[4,2,7,1,3,5]\n**解释：**另一个满足题目要求可以通过的树是：\n![image](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)\n`\n\n**示例 2：**\n\n`\n**输入：**root = [40,20,60,10,30,50,70], val = 25\n**输出：**[40,20,60,10,30,50,70,null,null,25]\n`\n\n**示例 3：**\n\n`\n**输入：**root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n**输出：**[4,2,7,1,3,5]\n`\n\n \n\n \n\n**提示：**\n\n*   给定的树上的节点数介于 `0` 和 `10^4` 之间\n*   每个节点都有一个唯一整数值，取值范围从 `0` 到 `10^8`\n*   `-10^8 \u003c= val \u003c= 10^8`\n*   新值和原始二叉搜索树中的任意节点值都不同"},"k-th-symbol-in-grammar":{"title":"K-th Symbol in Grammar","translated_title":"第K个语法符号","question_id":"795","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["递归"],"difficulty":"中等","save_dir":["questions/serial/中等/795","questions/tags/递归/中等/k-th-symbol-in-grammar"],"title_slug":"k-th-symbol-in-grammar","question":"## [第K个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\n在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。\n\n给定行数 `N` 和序数 `K`，返回第 `N` 行中第 `K`个字符。（`K`从1开始）\n\n**例子:**\n\n`**输入:** N = 1, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 2\n**输出:** 1\n\n**输入:** N = 4, K = 5\n**输出:** 1\n\n**解释:**\n第一行: 0\n第二行: 01\n第三行: 0110\n第四行: 01101001\n`\n\n**注意：**\n\n1.  `N` 的范围 `[1, 30]`.\n2.  `K` 的范围 `[1, 2^(N-1)]`."},"keys-and-rooms":{"title":"Keys and Rooms","translated_title":"钥匙和房间","question_id":"871","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/871","questions/tags/深度优先搜索/中等/keys-and-rooms","questions/tags/图/中等/keys-and-rooms"],"title_slug":"keys-and-rooms","question":"## [钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n`**输入:** [[1],[2],[3],[]]\n**输出:** true\n**解释:** \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n`\n\n**示例 2：**\n\n`**输入：**[[1,3],[3,0,1],[2],[0]]\n**输出：**false\n**解释：**我们不能进入 2 号房间。\n`\n\n**提示：**\n\n1.  `1 \u003c= rooms.length \u003c= 1000`\n2.  `0 \u003c= rooms[i].length \u003c= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。"},"kth-largest-element-in-a-stream":{"title":"Kth Largest Element in a Stream","translated_title":"数据流中的第 K 大元素","question_id":"789","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["堆","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/789","questions/tags/堆/简单/kth-largest-element-in-a-stream","questions/tags/设计/简单/kth-largest-element-in-a-stream"],"title_slug":"kth-largest-element-in-a-stream","question":"## [数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)\n\n设计一个找到数据流中第 `k` 大元素的类（class）。注意是排序后的第 `k` 大元素，不是第 `k` 个不同的元素。\n\n请实现 `KthLargest` 类：\n\n*   `KthLargest(int k, int[] nums)` 使用整数 `k` 和整数流 `nums` 初始化对象。\n*   `int add(int val)` 返回当前数据流中第 `k` 大的元素。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n**输出：**\n[null, 4, 5, 5, 8, 8]\n\n**解释：**\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n`\n\n \n\n**提示：**\n\n*   `1 \n4\n`\n*   `0 \n4\n`\n*   `-10\n4\n \n4\n`\n*   `-10\n4\n \n4\n`\n*   最多调用 `add` 方法 `10\n4\n` 次\n*   题目数据保证，在查找第 `k` 大元素时，数组中至少有 `k` 个元素"},"lowest-common-ancestor-of-a-binary-search-tree":{"title":"Lowest Common Ancestor of a Binary Search Tree","translated_title":"二叉搜索树的最近公共祖先","question_id":"235","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/235","questions/tags/树/简单/lowest-common-ancestor-of-a-binary-search-tree"],"title_slug":"lowest-common-ancestor-of-a-binary-search-tree","question":"## [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)\n\n \n\n**示例 1:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n**输出:** 6 \n**解释:** 节点 `2 `和节点 `8 `的最近公共祖先是 `6。`\n`\n\n**示例 2:**\n\n`**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n**输出:** 2\n**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。`\n\n \n\n**说明:**\n\n*   所有节点的值都是唯一的。\n*   p、q 为不同节点且均存在于给定的二叉搜索树中。"},"maximum-repeating-substring":{"title":"Maximum Repeating Substring","translated_title":"最大重复子字符串","question_id":"1764","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/1764","questions/tags/字符串/简单/maximum-repeating-substring"],"title_slug":"maximum-repeating-substring","question":"## [最大重复子字符串](https://leetcode-cn.com/problems/maximum-repeating-substring/)\n\n给你一个字符串 `sequence` ，如果字符串 `word` 连续重复 `k` 次形成的字符串是 `sequence` 的一个子字符串，那么单词 `word` 的 **重复值为 `k`** **** 。单词 `word` 的 **最****大重复值** 是单词 `word` 在 `sequence` 中最大的重复值。如果 `word` 不是 `sequence` 的子串，那么重复值 `k` 为 `0` 。\n\n给你一个字符串 `sequence` 和 `word` ，请你返回 **最大重复值 `k`** 。\n\n \n\n**示例 1：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ab\"\n**输出：**2\n**解释：**\"abab\" 是 \"**abab**c\" 的子字符串。\n`\n\n**示例 2：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ba\"\n**输出：**1\n**解释：**\"ba\" 是 \"a**ba**bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。\n`\n\n**示例 3：**\n\n`\n**输入：**sequence = \"ababc\", word = \"ac\"\n**输出：**0\n**解释：**\"ac\" 不是 \"ababc\" 的子字符串。\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= sequence.length \u003c= 100`\n*   `1 \u003c= word.length \u003c= 100`\n*   `sequence` 和 `word` 都只包含小写英文字母。"},"merge-two-sorted-lists":{"title":"Merge Two Sorted Lists","translated_title":"合并两个有序链表","question_id":"21","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"简单","save_dir":["questions/serial/简单/21","questions/tags/链表/简单/merge-two-sorted-lists"],"title_slug":"merge-two-sorted-lists","question":"## [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n**示例：**\n\n`**输入：**1-\u003e2-\u003e4, 1-\u003e3-\u003e4\n**输出：**1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4\n`"},"pascals-triangle":{"title":"Pascal's Triangle","translated_title":"杨辉三角","question_id":"118","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/118","questions/tags/数组/简单/pascals-triangle"],"title_slug":"pascals-triangle","question":"## [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\n给定一个非负整数 _numRows，_生成杨辉三角的前 _numRows _行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 5\n**输出:**\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]`"},"pascals-triangle-ii":{"title":"Pascal's Triangle II","translated_title":"杨辉三角 II","question_id":"119","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/119","questions/tags/数组/简单/pascals-triangle-ii"],"title_slug":"pascals-triangle-ii","question":"## [杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n给定一个非负索引 _k_，其中 _k_ ≤ 33，返回杨辉三角的第 _k_ 行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 3\n**输出:** [1,3,3,1]\n`\n\n**进阶：**\n\n你可以优化你的算法到 _O_(_k_) 空间复杂度吗？"},"powx-n":{"title":"Pow(x, n)","translated_title":"Pow(x, n)","question_id":"50","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/50","questions/tags/数学/中等/powx-n","questions/tags/二分查找/中等/powx-n"],"title_slug":"powx-n","question":"## [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。\n\n**示例 1:**\n\n`**输入:** 2.00000, 10\n**输出:** 1024.00000\n`\n\n**示例 2:**\n\n`**输入:** 2.10000, 3\n**输出:** 9.26100\n`\n\n**示例 3:**\n\n`**输入:** 2.00000, -2\n**输出:** 0.25000\n**解释:** 2\n-2\n = 1/2\n2\n = 1/4 = 0.25`\n\n**说明:**\n\n*   -100.0 \u003c _x_ \u003c 100.0\n*   _n_ 是 32 位有符号整数，其数值范围是 [−2\n31\n, 2\n31 \n− 1] 。"},"reverse-string":{"title":"Reverse String","translated_title":"反转字符串","question_id":"344","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/344","questions/tags/双指针/简单/reverse-string","questions/tags/字符串/简单/reverse-string"],"title_slug":"reverse-string","question":"## [反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。\n\n \n\n**示例 1：**\n\n`**输入：**[\"h\",\"e\",\"l\",\"l\",\"o\"]\n**输出：**[\"o\",\"l\",\"l\",\"e\",\"h\"]\n`\n\n**示例 2：**\n\n`**输入：**[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n**输出：**[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]`"},"richest-customer-wealth":{"title":"Richest Customer Wealth","translated_title":"最富有客户的资产总量","question_id":"1791","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/1791","questions/tags/数组/简单/richest-customer-wealth"],"title_slug":"richest-customer-wealth","question":"## [最富有客户的资产总量](https://leetcode-cn.com/problems/richest-customer-wealth/)\n\n给你一个 `m x n` 的整数网格 `accounts` ，其中 `accounts[i][j]` 是第 `i​​​​​\n​​​​​​\n​` 位客户在第 `j` 家银行托管的资产数量。返回最富有客户所拥有的 **资产总量** 。\n\n客户的 **资产总量** 就是他们在各家银行托管的资产数量之和。最富有客户就是 **资产总量** 最大的客户。\n\n \n\n**示例 1：**\n\n`**输入：**accounts = [[1,2,3],[3,2,1]]\n**输出：**6\n**解释：**\n`第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n`两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n`\n\n**示例 2：**\n\n`**输入：**accounts = [[1,5],[7,3],[3,5]]\n**输出：**10\n**解释：**\n`第 1 位客户的资产总量` = 6\n`第 2 位客户的资产总量` = 10 \n`第 3 位客户的资产总量` = 8\n第 2 位客户是最富有的，资产总量是 10`\n\n**示例 3：**\n\n`**输入：**accounts = [[2,8,7],[7,1,3],[1,9,5]]\n**输出：**17\n`\n\n \n\n**提示：**\n\n*   `m == accounts.length`\n*   `n == accounts[i].length`\n*   `1 \u003c= m, n \u003c= 50`\n*   `1 \u003c= accounts[i][j] \u003c= 100`"},"search-in-a-binary-search-tree":{"title":"Search in a Binary Search Tree","translated_title":"二叉搜索树中的搜索","question_id":"783","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/783","questions/tags/树/简单/search-in-a-binary-search-tree"],"title_slug":"search-in-a-binary-search-tree","question":"## [二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n例如，\n\n`\n给定二叉搜索树:\n\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\n和值: 2\n`\n\n你应该返回如下子树:\n\n`\n      2     \n     / \\   \n    1   3\n`\n\n在上述示例中，如果要找的值是 `5`，但因为没有节点值为 `5`，我们应该返回 `NULL`。"},"search-in-rotated-sorted-array":{"title":"Search in Rotated Sorted Array","translated_title":"搜索旋转排序数组","question_id":"33","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/33","questions/tags/数组/中等/search-in-rotated-sorted-array","questions/tags/二分查找/中等/search-in-rotated-sorted-array"],"title_slug":"search-in-rotated-sorted-array","question":"## [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n\n给你一个整数数组 `nums` ，和一个整数 `target` 。\n\n该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` ）。\n\n请你在数组中搜索 `target` ，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。\n\n \n\n**示例 1：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 0\n**输出：**4\n`\n\n**示例 2：**\n\n`\n**输入：**nums = [`4,5,6,7,0,1,2]`, target = 3\n**输出：**-1`\n\n**示例 3：**\n\n`\n**输入：**nums = [1], target = 0\n**输出：**-1\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= nums.length \u003c= 5000`\n*   `-10^4 \u003c= nums[i] \u003c= 10^4`\n*   `nums` 中的每个值都 **独一无二**\n*   `nums` 肯定会在某个点上旋转\n*   `-10^4 \u003c= target \u003c= 10^4`"},"search-insert-position":{"title":"Search Insert Position","translated_title":"搜索插入位置","question_id":"35","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/35","questions/tags/数组/简单/search-insert-position","questions/tags/二分查找/简单/search-insert-position"],"title_slug":"search-insert-position","question":"## [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n**示例 1:**\n\n`**输入:** [1,3,5,6], 5\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** [1,3,5,6], 2\n**输出:** 1\n`\n\n**示例 3:**\n\n`**输入:** [1,3,5,6], 7\n**输出:** 4\n`\n\n**示例 4:**\n\n`**输入:** [1,3,5,6], 0\n**输出:** 0\n`"},"sqrtx":{"title":"Sqrt(x)","translated_title":"x 的平方根","question_id":"69","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"简单","save_dir":["questions/serial/简单/69","questions/tags/数学/简单/sqrtx","questions/tags/二分查找/简单/sqrtx"],"title_slug":"sqrtx","question":"## [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)\n\n实现 `int sqrt(int x)` 函数。\n\n计算并返回 _x_ 的平方根，其中 _x_ 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n**示例 1:**\n\n`**输入:** 4\n**输出:** 2\n`\n\n**示例 2:**\n\n`**输入:** 8\n**输出:** 2\n**说明:** 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n`"},"swap-nodes-in-pairs":{"title":"Swap Nodes in Pairs","translated_title":"两两交换链表中的节点","question_id":"24","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"中等","save_dir":["questions/serial/中等/24","questions/tags/链表/中等/swap-nodes-in-pairs"],"title_slug":"swap-nodes-in-pairs","question":"## [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n`\n**输入：**head = [1,2,3,4]\n**输出：**[2,1,4,3]\n`\n\n**示例 2：**\n\n`\n**输入：**head = []\n**输出：**[]\n`\n\n**示例 3：**\n\n`\n**输入：**head = [1]\n**输出：**[1]\n`\n\n \n\n**提示：**\n\n*   链表中节点的数目在范围 `[0, 100]` 内\n*   `0 \u003c= Node.val \u003c= 100`"},"symmetric-tree":{"title":"Symmetric Tree","translated_title":"对称二叉树","question_id":"101","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索","广度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/101","questions/tags/树/简单/symmetric-tree","questions/tags/深度优先搜索/简单/symmetric-tree","questions/tags/广度优先搜索/简单/symmetric-tree"],"title_slug":"symmetric-tree","question":"## [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n`    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n`\n\n \n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n`    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n`\n\n \n\n**进阶：**\n\n你可以运用递归和迭代两种方法解决这个问题吗？"},"target-sum":{"title":"Target Sum","translated_title":"目标和","question_id":"494","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/494","questions/tags/深度优先搜索/中等/target-sum","questions/tags/动态规划/中等/target-sum"],"title_slug":"target-sum","question":"## [目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n \n\n**示例：**\n\n`**输入：**nums: [1, 1, 1, 1, 1], S: 3\n**输出：**5\n**解释：**\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n`\n\n \n\n**提示：**\n\n*   数组非空，且长度不会超过 20 。\n*   初始的数组的和不会超过 1000 。\n*   保证返回的最终结果能被 32 位整数存下。"},"unique-binary-search-trees-ii":{"title":"Unique Binary Search Trees II","translated_title":"不同的二叉搜索树 II","question_id":"95","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/95","questions/tags/树/中等/unique-binary-search-trees-ii","questions/tags/动态规划/中等/unique-binary-search-trees-ii"],"title_slug":"unique-binary-search-trees-ii","question":"## [不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 _n_，生成所有由 1 ... _n_ 为节点所组成的 **二叉搜索树** 。\n\n \n\n**示例：**\n\n`**输入：**3\n**输出：**\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n**解释：**\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 8`"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","translated_title":"验证二叉搜索树","question_id":"98","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/98","questions/tags/树/中等/validate-binary-search-tree","questions/tags/深度优先搜索/中等/validate-binary-search-tree"],"title_slug":"validate-binary-search-tree","question":"## [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n*   节点的左子树只包含**小于**当前节点的数。\n*   节点的右子树只包含**大于**当前节点的数。\n*   所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n`**输入:**\n    2\n   / \\\n  1   3\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:**     5\n   / \\\n  1   4\n     / \\\n    3   6\n**输出:** false\n**解释:** 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n`"}}