{"":{"title":"","translated_title":"","question_id":"","language":null,"tags":null,"difficulty":"","save_dir":["questions/serial"],"title_slug":"","question":"## [](https://leetcode-cn.com/problems//)\n\n"},"01-matrix":{"title":"01 Matrix","translated_title":"01 矩阵","question_id":"542","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","广度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/542","questions/tags/深度优先搜索/中等/01-matrix","questions/tags/广度优先搜索/中等/01-matrix"],"title_slug":"01-matrix","question":"## [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n \n\n**示例 1：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n`\n\n**示例 2：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n`\n\n \n\n**提示：**\n\n*   给定矩阵的元素个数不超过 10000。\n*   给定矩阵中至少有一个元素是 0。\n*   矩阵中的元素只在四个方向上相邻: 上、下、左、右。"},"binary-search-tree-iterator":{"title":"Binary Search Tree Iterator","translated_title":"二叉搜索树迭代器","question_id":"173","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","树","设计"],"difficulty":"中等","save_dir":["questions/serial/中等/173","questions/tags/栈/中等/binary-search-tree-iterator","questions/tags/树/中等/binary-search-tree-iterator","questions/tags/设计/中等/binary-search-tree-iterator"],"title_slug":"binary-search-tree-iterator","question":"## [二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 `next()` 将返回二叉搜索树中的下一个最小的数。\n\n \n\n**示例：**\n\n**![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/25/bst-tree.png)**\n\n`BSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false`\n\n \n\n**提示：**\n\n*   `next()` 和 `hasNext()` 操作的时间复杂度是 O(1)，并使用 O(_h_) 内存，其中 _h _是树的高度。\n*   你可以假设 `next()` 调用总是有效的，也就是说，当调用 `next()` 时，BST 中至少存在一个下一个最小的数。"},"climbing-stairs":{"title":"Climbing Stairs","translated_title":"爬楼梯","question_id":"70","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["动态规划"],"difficulty":"简单","save_dir":["questions/serial/简单/70","questions/tags/动态规划/简单/climbing-stairs"],"title_slug":"climbing-stairs","question":"## [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)\n\n假设你正在爬楼梯。需要 _n_ 阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n**注意：**给定 _n_ 是一个正整数。\n\n**示例 1：**\n\n`**输入：** 2\n**输出：** 2\n**解释：** 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶`\n\n**示例 2：**\n\n`**输入：** 3\n**输出：** 3\n**解释：** 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n`"},"clone-graph":{"title":"Clone Graph","translated_title":"克隆图","question_id":"133","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["深度优先搜索","广度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/133","questions/tags/深度优先搜索/中等/clone-graph","questions/tags/广度优先搜索/中等/clone-graph","questions/tags/图/中等/clone-graph"],"title_slug":"clone-graph","question":"## [克隆图](https://leetcode-cn.com/problems/clone-graph/)\n\n给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin) **图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。\n\n图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。\n\n`class Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n}`\n\n \n\n**测试用例格式：**\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。\n\n**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝 **作为对克隆图的引用返回。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)\n\n`**输入：**adjList = [[2,4],[1,3],[2,4],[1,3]]\n**输出：**[[2,4],[1,3],[2,4],[1,3]]\n**解释：** 图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)\n\n`**输入：**adjList = [[]]\n**输出：**[[]]\n**解释：**输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n`\n\n**示例 3：**\n\n`**输入：**adjList = []\n**输出：**[]\n**解释：**这个图是空的，它不含任何节点。\n`\n\n**示例 4：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)\n\n`**输入：**adjList = [[2],[1]]\n**输出：**[[2],[1]]`\n\n \n\n**提示：**\n\n1.  节点数不超过 100 。\n2.  每个节点值 `Node.val` 都是唯一的，`1 \u003c= Node.val \u003c= 100`。\n3.  无向图是一个[简单图](https://baike.baidu.com/item/简单图/1680528?fr=aladdin)，这意味着图中没有重复的边，也没有自环。\n4.  由于图是无向的，如果节点 _p_ 是节点 _q_ 的邻居，那么节点 _q_ 也必须是节点 _p_ 的邻居。\n5.  图是连通图，你可以从给定节点访问到所有节点。"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","translated_title":"完全二叉树的节点个数","question_id":"222","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/222","questions/tags/树/中等/count-complete-tree-nodes","questions/tags/二分查找/中等/count-complete-tree-nodes"],"title_slug":"count-complete-tree-nodes","question":"## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2\nh\n 个节点。\n\n**示例:**\n\n`**输入:** \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n**输出:** 6`"},"decode-string":{"title":"Decode String","translated_title":"字符串解码","question_id":"394","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/394","questions/tags/栈/中等/decode-string","questions/tags/深度优先搜索/中等/decode-string"],"title_slug":"decode-string","question":"## [字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 _encoded_string_ 正好重复 _k_ 次。注意 _k_ 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 _k_ ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n`**输入：**s = \"3[a]2[bc]\"\n**输出：**\"aaabcbc\"\n`\n\n**示例 2：**\n\n`**输入：**s = \"3[a2[c]]\"\n**输出：**\"accaccacc\"\n`\n\n**示例 3：**\n\n`**输入：**s = \"2[abc]3[cd]ef\"\n**输出：**\"abcabccdcdcdef\"\n`\n\n**示例 4：**\n\n`**输入：**s = \"abc3[cd]xyz\"\n**输出：**\"abccdcdcdxyz\"\n`"},"fibonacci-number":{"title":"Fibonacci Number","translated_title":"斐波那契数","question_id":"1013","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/1013","questions/tags/数组/简单/fibonacci-number"],"title_slug":"fibonacci-number","question":"## [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)\n\n**斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n`F(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1.\n`\n\n给定 `N`，计算 `F(N)`。\n\n \n\n**示例 1：**\n\n`**输入：**2\n**输出：**1\n**解释：**F(2) = F(1) + F(0) = 1 + 0 = 1.\n`\n\n**示例 2：**\n\n`**输入：**3\n**输出：**2\n**解释：**F(3) = F(2) + F(1) = 1 + 1 = 2.\n`\n\n**示例 3：**\n\n`**输入：**4\n**输出：**3\n**解释：**F(4) = F(3) + F(2) = 2 + 1 = 3.\n`\n\n \n\n**提示：**\n\n*   0 ≤ `N` ≤ 30"},"flood-fill":{"title":"Flood Fill","translated_title":"图像渲染","question_id":"733","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/733","questions/tags/深度优先搜索/简单/flood-fill"],"title_slug":"flood-fill","question":"## [图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n`\n**输入:** \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n**输出:** [[2,2,2],[2,2,0],[2,0,1]]\n**解析:** \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n`\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 \u003c= sr \u003c image.length` 和 `0 \u003c= sc \u003c image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。"},"implement-queue-using-stacks":{"title":"Implement Queue using Stacks","translated_title":"用栈实现队列","question_id":"232","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/232","questions/tags/栈/简单/implement-queue-using-stacks","questions/tags/设计/简单/implement-queue-using-stacks"],"title_slug":"implement-queue-using-stacks","question":"## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n*   `void push(int x)` 将元素 x 推到队列的末尾\n*   `int pop()` 从队列的开头移除并返回元素\n*   `int peek()` 返回队列开头的元素\n*   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n \n\n**说明：**\n\n*   你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n*   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**进阶：**\n\n*   你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n**输出：**\n[null, null, null, 1, 1, false]\n\n**解释：**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= x \u003c= 9`\n*   最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n*   假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）"},"implement-stack-using-queues":{"title":"Implement Stack using Queues","translated_title":"用队列实现栈","question_id":"225","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/225","questions/tags/栈/简单/implement-stack-using-queues","questions/tags/设计/简单/implement-stack-using-queues"],"title_slug":"implement-stack-using-queues","question":"## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n使用队列实现栈的下列操作：\n\n*   push(x) -- 元素 x 入栈\n*   pop() -- 移除栈顶元素\n*   top() -- 获取栈顶元素\n*   empty() -- 返回栈是否为空\n\n**注意:**\n\n*   你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。\n*   你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n*   你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。"},"insert-into-a-binary-search-tree":{"title":"Insert into a Binary Search Tree","translated_title":"二叉搜索树中的插入操作","question_id":"784","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"中等","save_dir":["questions/serial/中等/784","questions/tags/树/中等/insert-into-a-binary-search-tree"],"title_slug":"insert-into-a-binary-search-tree","question":"## [二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n\n**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n`\n**输入：**root = [4,2,7,1,3], val = 5\n**输出：**[4,2,7,1,3,5]\n**解释：**另一个满足题目要求可以通过的树是：\n![image](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)\n`\n\n**示例 2：**\n\n`\n**输入：**root = [40,20,60,10,30,50,70], val = 25\n**输出：**[40,20,60,10,30,50,70,null,null,25]\n`\n\n**示例 3：**\n\n`\n**输入：**root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n**输出：**[4,2,7,1,3,5]\n`\n\n \n\n \n\n**提示：**\n\n*   给定的树上的节点数介于 `0` 和 `10^4` 之间\n*   每个节点都有一个唯一整数值，取值范围从 `0` 到 `10^8`\n*   `-10^8 \u003c= val \u003c= 10^8`\n*   新值和原始二叉搜索树中的任意节点值都不同"},"k-th-symbol-in-grammar":{"title":"K-th Symbol in Grammar","translated_title":"第K个语法符号","question_id":"795","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["递归"],"difficulty":"中等","save_dir":["questions/serial/中等/795","questions/tags/递归/中等/k-th-symbol-in-grammar"],"title_slug":"k-th-symbol-in-grammar","question":"## [第K个语法符号](https://leetcode-cn.com/problems/k-th-symbol-in-grammar/)\n\n在第一行我们写上一个 `0`。接下来的每一行，将前一行中的`0`替换为`01`，`1`替换为`10`。\n\n给定行数 `N` 和序数 `K`，返回第 `N` 行中第 `K`个字符。（`K`从1开始）\n\n**例子:**\n\n`**输入:** N = 1, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 1\n**输出:** 0\n\n**输入:** N = 2, K = 2\n**输出:** 1\n\n**输入:** N = 4, K = 5\n**输出:** 1\n\n**解释:**\n第一行: 0\n第二行: 01\n第三行: 0110\n第四行: 01101001\n`\n\n**注意：**\n\n1.  `N` 的范围 `[1, 30]`.\n2.  `K` 的范围 `[1, 2^(N-1)]`."},"keys-and-rooms":{"title":"Keys and Rooms","translated_title":"钥匙和房间","question_id":"871","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/871","questions/tags/深度优先搜索/中等/keys-and-rooms","questions/tags/图/中等/keys-and-rooms"],"title_slug":"keys-and-rooms","question":"## [钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n如果能进入每个房间返回 `true`，否则返回 `false`。\n\n**示例 1：**\n\n`**输入:** [[1],[2],[3],[]]\n**输出:** true\n**解释:** \n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n`\n\n**示例 2：**\n\n`**输入：**[[1,3],[3,0,1],[2],[0]]\n**输出：**false\n**解释：**我们不能进入 2 号房间。\n`\n\n**提示：**\n\n1.  `1 \u003c= rooms.length \u003c= 1000`\n2.  `0 \u003c= rooms[i].length \u003c= 1000`\n3.  所有房间中的钥匙数量总计不超过 `3000`。"},"merge-two-sorted-lists":{"title":"Merge Two Sorted Lists","translated_title":"合并两个有序链表","question_id":"21","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"简单","save_dir":["questions/serial/简单/21","questions/tags/链表/简单/merge-two-sorted-lists"],"title_slug":"merge-two-sorted-lists","question":"## [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n \n\n**示例：**\n\n`**输入：**1-\u003e2-\u003e4, 1-\u003e3-\u003e4\n**输出：**1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4\n`"},"pascals-triangle":{"title":"Pascal's Triangle","translated_title":"杨辉三角","question_id":"118","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/118","questions/tags/数组/简单/pascals-triangle"],"title_slug":"pascals-triangle","question":"## [杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)\n\n给定一个非负整数 _numRows，_生成杨辉三角的前 _numRows _行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 5\n**输出:**\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]`"},"pascals-triangle-ii":{"title":"Pascal's Triangle II","translated_title":"杨辉三角 II","question_id":"119","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数组"],"difficulty":"简单","save_dir":["questions/serial/简单/119","questions/tags/数组/简单/pascals-triangle-ii"],"title_slug":"pascals-triangle-ii","question":"## [杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)\n\n给定一个非负索引 _k_，其中 _k_ ≤ 33，返回杨辉三角的第 _k_ 行。\n\n![image](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n\n**示例:**\n\n`**输入:** 3\n**输出:** [1,3,3,1]\n`\n\n**进阶：**\n\n你可以优化你的算法到 _O_(_k_) 空间复杂度吗？"},"powx-n":{"title":"Pow(x, n)","translated_title":"Pow(x, n)","question_id":"50","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["数学","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/50","questions/tags/数学/中等/powx-n","questions/tags/二分查找/中等/powx-n"],"title_slug":"powx-n","question":"## [Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)\n\n实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。\n\n**示例 1:**\n\n`**输入:** 2.00000, 10\n**输出:** 1024.00000\n`\n\n**示例 2:**\n\n`**输入:** 2.10000, 3\n**输出:** 9.26100\n`\n\n**示例 3:**\n\n`**输入:** 2.00000, -2\n**输出:** 0.25000\n**解释:** 2\n-2\n = 1/2\n2\n = 1/4 = 0.25`\n\n**说明:**\n\n*   -100.0 \u003c _x_ \u003c 100.0\n*   _n_ 是 32 位有符号整数，其数值范围是 [−2\n31\n, 2\n31 \n− 1] 。"},"reverse-string":{"title":"Reverse String","translated_title":"反转字符串","question_id":"344","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["双指针","字符串"],"difficulty":"简单","save_dir":["questions/serial/简单/344","questions/tags/双指针/简单/reverse-string","questions/tags/字符串/简单/reverse-string"],"title_slug":"reverse-string","question":"## [反转字符串](https://leetcode-cn.com/problems/reverse-string/)\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。\n\n \n\n**示例 1：**\n\n`**输入：**[\"h\",\"e\",\"l\",\"l\",\"o\"]\n**输出：**[\"o\",\"l\",\"l\",\"e\",\"h\"]\n`\n\n**示例 2：**\n\n`**输入：**[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n**输出：**[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]`"},"search-in-a-binary-search-tree":{"title":"Search in a Binary Search Tree","translated_title":"二叉搜索树中的搜索","question_id":"783","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树"],"difficulty":"简单","save_dir":["questions/serial/简单/783","questions/tags/树/简单/search-in-a-binary-search-tree"],"title_slug":"search-in-a-binary-search-tree","question":"## [二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)\n\n给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。\n\n例如，\n\n`\n给定二叉搜索树:\n\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\n和值: 2\n`\n\n你应该返回如下子树:\n\n`\n      2     \n     / \\   \n    1   3\n`\n\n在上述示例中，如果要找的值是 `5`，但因为没有节点值为 `5`，我们应该返回 `NULL`。"},"swap-nodes-in-pairs":{"title":"Swap Nodes in Pairs","translated_title":"两两交换链表中的节点","question_id":"24","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["链表"],"difficulty":"中等","save_dir":["questions/serial/中等/24","questions/tags/链表/中等/swap-nodes-in-pairs"],"title_slug":"swap-nodes-in-pairs","question":"## [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n`\n**输入：**head = [1,2,3,4]\n**输出：**[2,1,4,3]\n`\n\n**示例 2：**\n\n`\n**输入：**head = []\n**输出：**[]\n`\n\n**示例 3：**\n\n`\n**输入：**head = [1]\n**输出：**[1]\n`\n\n \n\n**提示：**\n\n*   链表中节点的数目在范围 `[0, 100]` 内\n*   `0 \u003c= Node.val \u003c= 100`"},"symmetric-tree":{"title":"Symmetric Tree","translated_title":"对称二叉树","question_id":"101","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索","广度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/101","questions/tags/树/简单/symmetric-tree","questions/tags/深度优先搜索/简单/symmetric-tree","questions/tags/广度优先搜索/简单/symmetric-tree"],"title_slug":"symmetric-tree","question":"## [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n`    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n`\n\n \n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n`    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n`\n\n \n\n**进阶：**\n\n你可以运用递归和迭代两种方法解决这个问题吗？"},"target-sum":{"title":"Target Sum","translated_title":"目标和","question_id":"494","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/494","questions/tags/深度优先搜索/中等/target-sum","questions/tags/动态规划/中等/target-sum"],"title_slug":"target-sum","question":"## [目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n \n\n**示例：**\n\n`**输入：**nums: [1, 1, 1, 1, 1], S: 3\n**输出：**5\n**解释：**\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n`\n\n \n\n**提示：**\n\n*   数组非空，且长度不会超过 20 。\n*   初始的数组的和不会超过 1000 。\n*   保证返回的最终结果能被 32 位整数存下。"},"unique-binary-search-trees-ii":{"title":"Unique Binary Search Trees II","translated_title":"不同的二叉搜索树 II","question_id":"95","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/95","questions/tags/树/中等/unique-binary-search-trees-ii","questions/tags/动态规划/中等/unique-binary-search-trees-ii"],"title_slug":"unique-binary-search-trees-ii","question":"## [不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)\n\n给定一个整数 _n_，生成所有由 1 ... _n_ 为节点所组成的 **二叉搜索树** 。\n\n \n\n**示例：**\n\n`**输入：**3\n**输出：**\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n**解释：**\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n`\n\n \n\n**提示：**\n\n*   `0 \u003c= n \u003c= 8`"},"validate-binary-search-tree":{"title":"Validate Binary Search Tree","translated_title":"验证二叉搜索树","question_id":"98","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/98","questions/tags/树/中等/validate-binary-search-tree","questions/tags/深度优先搜索/中等/validate-binary-search-tree"],"title_slug":"validate-binary-search-tree","question":"## [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n*   节点的左子树只包含**小于**当前节点的数。\n*   节点的右子树只包含**大于**当前节点的数。\n*   所有左子树和右子树自身必须也是二叉搜索树。\n\n**示例 1:**\n\n`**输入:**\n    2\n   / \\\n  1   3\n**输出:** true\n`\n\n**示例 2:**\n\n`**输入:**     5\n   / \\\n  1   4\n     / \\\n    3   6\n**输出:** false\n**解释:** 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n`"}}