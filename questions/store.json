{"":{"title":"","translated_title":"","question_id":"","language":null,"tags":null,"difficulty":"","save_dir":["questions/serial"],"title_slug":"","question":"## [](https://leetcode-cn.com/problems//)\n\n"},"01-matrix":{"title":"01 Matrix","translated_title":"01 矩阵","question_id":"542","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","广度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/542","questions/tags/深度优先搜索/中等/01-matrix","questions/tags/广度优先搜索/中等/01-matrix"],"title_slug":"01-matrix","question":"## [01 矩阵](https://leetcode-cn.com/problems/01-matrix/)\n\n给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。\n\n两个相邻元素间的距离为 1 。\n\n \n\n**示例 1：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n`\n\n**示例 2：**\n\n`\n**输入：**\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n**输出：**\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n`\n\n \n\n**提示：**\n\n*   给定矩阵的元素个数不超过 10000。\n*   给定矩阵中至少有一个元素是 0。\n*   矩阵中的元素只在四个方向上相邻: 上、下、左、右。"},"clone-graph":{"title":"Clone Graph","translated_title":"克隆图","question_id":"133","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","php","typescript"],"tags":["深度优先搜索","广度优先搜索","图"],"difficulty":"中等","save_dir":["questions/serial/中等/133","questions/tags/深度优先搜索/中等/clone-graph","questions/tags/广度优先搜索/中等/clone-graph","questions/tags/图/中等/clone-graph"],"title_slug":"clone-graph","question":"## [克隆图](https://leetcode-cn.com/problems/clone-graph/)\n\n给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin) **图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。\n\n图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。\n\n`class Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n}`\n\n \n\n**测试用例格式：**\n\n简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（`val = 1`），第二个节点值为 2（`val = 2`），以此类推。该图在测试用例中使用邻接列表表示。\n\n**邻接列表** 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。\n\n给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝 **作为对克隆图的引用返回。\n\n \n\n**示例 1：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)\n\n`**输入：**adjList = [[2,4],[1,3],[2,4],[1,3]]\n**输出：**[[2,4],[1,3],[2,4],[1,3]]\n**解释：** 图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n`\n\n**示例 2：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png)\n\n`**输入：**adjList = [[]]\n**输出：**[[]]\n**解释：**输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n`\n\n**示例 3：**\n\n`**输入：**adjList = []\n**输出：**[]\n**解释：**这个图是空的，它不含任何节点。\n`\n\n**示例 4：**\n\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png)\n\n`**输入：**adjList = [[2],[1]]\n**输出：**[[2],[1]]`\n\n \n\n**提示：**\n\n1.  节点数不超过 100 。\n2.  每个节点值 `Node.val` 都是唯一的，`1 \u003c= Node.val \u003c= 100`。\n3.  无向图是一个[简单图](https://baike.baidu.com/item/简单图/1680528?fr=aladdin)，这意味着图中没有重复的边，也没有自环。\n4.  由于图是无向的，如果节点 _p_ 是节点 _q_ 的邻居，那么节点 _q_ 也必须是节点 _p_ 的邻居。\n5.  图是连通图，你可以从给定节点访问到所有节点。"},"count-complete-tree-nodes":{"title":"Count Complete Tree Nodes","translated_title":"完全二叉树的节点个数","question_id":"222","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","二分查找"],"difficulty":"中等","save_dir":["questions/serial/中等/222","questions/tags/树/中等/count-complete-tree-nodes","questions/tags/二分查找/中等/count-complete-tree-nodes"],"title_slug":"count-complete-tree-nodes","question":"## [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)\n\n给出一个**完全二叉树**，求出该树的节点个数。\n\n**说明：**\n\n[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2\nh\n 个节点。\n\n**示例:**\n\n`**输入:** \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\n**输出:** 6`"},"decode-string":{"title":"Decode String","translated_title":"字符串解码","question_id":"394","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","深度优先搜索"],"difficulty":"中等","save_dir":["questions/serial/中等/394","questions/tags/栈/中等/decode-string","questions/tags/深度优先搜索/中等/decode-string"],"title_slug":"decode-string","question":"## [字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 _encoded_string_ 正好重复 _k_ 次。注意 _k_ 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 _k_ ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n \n\n**示例 1：**\n\n`**输入：**s = \"3[a]2[bc]\"\n**输出：**\"aaabcbc\"\n`\n\n**示例 2：**\n\n`**输入：**s = \"3[a2[c]]\"\n**输出：**\"accaccacc\"\n`\n\n**示例 3：**\n\n`**输入：**s = \"2[abc]3[cd]ef\"\n**输出：**\"abcabccdcdcdef\"\n`\n\n**示例 4：**\n\n`**输入：**s = \"abc3[cd]xyz\"\n**输出：**\"abccdcdcdxyz\"\n`"},"flood-fill":{"title":"Flood Fill","translated_title":"图像渲染","question_id":"733","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/733","questions/tags/深度优先搜索/简单/flood-fill"],"title_slug":"flood-fill","question":"## [图像渲染](https://leetcode-cn.com/problems/flood-fill/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n**示例 1:**\n\n`\n**输入:** \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n**输出:** [[2,2,2],[2,2,0],[2,0,1]]\n**解析:** \n在图像的正中间，(坐标(sr,sc)=(1,1)),\n在路径上所有符合条件的像素点的颜色都被更改成2。\n注意，右下角的像素没有更改为2，\n因为它不是在上下左右四个方向上与初始点相连的像素点。\n`\n\n**注意:**\n\n*   `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。\n*   给出的初始点将满足 `0 \u003c= sr \u003c image.length` 和 `0 \u003c= sc \u003c image[0].length`。\n*   `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。"},"implement-queue-using-stacks":{"title":"Implement Queue using Stacks","translated_title":"用栈实现队列","question_id":"232","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/232","questions/tags/栈/简单/implement-queue-using-stacks","questions/tags/设计/简单/implement-queue-using-stacks"],"title_slug":"implement-queue-using-stacks","question":"## [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n\n实现 `MyQueue` 类：\n\n*   `void push(int x)` 将元素 x 推到队列的末尾\n*   `int pop()` 从队列的开头移除并返回元素\n*   `int peek()` 返回队列开头的元素\n*   `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n\n \n\n**说明：**\n\n*   你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n*   你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n**进阶：**\n\n*   你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n\n \n\n**示例：**\n\n`\n**输入：**\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n**输出：**\n[null, null, null, 1, 1, false]\n\n**解释：**\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n`\n\n \n\n**提示：**\n\n*   `1 \u003c= x \u003c= 9`\n*   最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\n*   假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）"},"implement-stack-using-queues":{"title":"Implement Stack using Queues","translated_title":"用队列实现栈","question_id":"225","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["栈","设计"],"difficulty":"简单","save_dir":["questions/serial/简单/225","questions/tags/栈/简单/implement-stack-using-queues","questions/tags/设计/简单/implement-stack-using-queues"],"title_slug":"implement-stack-using-queues","question":"## [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)\n\n使用队列实现栈的下列操作：\n\n*   push(x) -- 元素 x 入栈\n*   pop() -- 移除栈顶元素\n*   top() -- 获取栈顶元素\n*   empty() -- 返回栈是否为空\n\n**注意:**\n\n*   你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。\n*   你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n*   你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。"},"symmetric-tree":{"title":"Symmetric Tree","translated_title":"对称二叉树","question_id":"101","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["树","深度优先搜索","广度优先搜索"],"difficulty":"简单","save_dir":["questions/serial/简单/101","questions/tags/树/简单/symmetric-tree","questions/tags/深度优先搜索/简单/symmetric-tree","questions/tags/广度优先搜索/简单/symmetric-tree"],"title_slug":"symmetric-tree","question":"## [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)\n\n给定一个二叉树，检查它是否是镜像对称的。\n\n \n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n`    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n`\n\n \n\n但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:\n\n`    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n`\n\n \n\n**进阶：**\n\n你可以运用递归和迭代两种方法解决这个问题吗？"},"target-sum":{"title":"Target Sum","translated_title":"目标和","question_id":"494","language":["cpp","java","python","python3","c","csharp","javascript","ruby","swift","golang","scala","kotlin","rust","php","typescript"],"tags":["深度优先搜索","动态规划"],"difficulty":"中等","save_dir":["questions/serial/中等/494","questions/tags/深度优先搜索/中等/target-sum","questions/tags/动态规划/中等/target-sum"],"title_slug":"target-sum","question":"## [目标和](https://leetcode-cn.com/problems/target-sum/)\n\n给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。\n\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n\n \n\n**示例：**\n\n`**输入：**nums: [1, 1, 1, 1, 1], S: 3\n**输出：**5\n**解释：**\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\n一共有5种方法让最终目标和为3。\n`\n\n \n\n**提示：**\n\n*   数组非空，且长度不会超过 20 。\n*   初始的数组的和不会超过 1000 。\n*   保证返回的最终结果能被 32 位整数存下。"}}